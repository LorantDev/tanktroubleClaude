<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TANK SIEGE</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TANK SIEGE â€” Styles
   Theme: Military Industrial / CRT Terminal
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
:root {
  --bg:#09090f;--bg2:#0f101a;--panel:#12141f;--panel2:#181b2a;
  --border:#252840;--border2:#353a5a;
  --gold:#c8a84b;--gold2:#e8c870;--gold3:#f5d98a;
  --red:#d9453a;--grn:#42c87a;--blu:#4a9fd4;--pur:#b06ae0;
  --dim:#424870;--text:#b8bdd8;--textd:#606888;
  --mono:'Courier New',monospace;--sans:'Arial Narrow',Arial,sans-serif;
  --p0:#e8543a;--p1:#4a9fd4;--p2:#42c87a;--p3:#b06ae0;
  --p4:#e8c870;--p5:#d44a88;--p6:#42c8c8;--p7:#ff8c42;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html,body{width:100%;height:100%;background:var(--bg);color:var(--text);font-family:var(--sans);overflow:hidden;user-select:none;-webkit-user-select:none;touch-action:none;}
#app{width:100%;height:100%;position:fixed;top:0;left:0;right:0;bottom:0;}

/* â”€â”€ Screens â”€â”€ */
.screen{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column}
.screen.active{display:flex}

/* â”€â”€ Menu Background Animated Canvas â”€â”€ */
#bg-canvas{position:absolute;inset:0;width:100%;height:100%;opacity:.3;pointer-events:none}

/* â”€â”€ Menu â”€â”€ */
.menu-wrap{position:relative;display:flex;flex-direction:column;align-items:center;gap:44px}
.title-eyebrow{font-family:var(--mono);font-size:11px;letter-spacing:.35em;color:var(--gold);text-transform:uppercase;margin-bottom:4px}
.title-main{font-family:var(--sans);font-size:clamp(60px,9vw,112px);font-weight:900;letter-spacing:-.02em;line-height:.9;color:#fff;text-shadow:0 0 30px rgba(200,168,75,.5),0 0 80px rgba(200,168,75,.15),0 2px 0 rgba(0,0,0,.8)}
.title-sub{font-family:var(--mono);font-size:10px;letter-spacing:.25em;color:var(--dim);margin-top:14px}
.menu-btns{display:flex;flex-direction:column;gap:10px;align-items:stretch;width:270px}
.menu-footer{font-family:var(--mono);font-size:9px;color:var(--textd);letter-spacing:.15em;margin-top:-20px}

/* â”€â”€ Buttons â”€â”€ */
.btn{font-family:var(--sans);font-weight:700;font-size:14px;letter-spacing:.12em;text-transform:uppercase;padding:11px 26px;border:2px solid transparent;cursor:pointer;background:transparent;transition:all .12s;clip-path:polygon(8px 0%,100% 0%,calc(100% - 8px) 100%,0% 100%)}
.btn-gold{border-color:var(--gold);color:var(--gold)}
.btn-gold:hover{background:var(--gold);color:#000;box-shadow:0 0 18px rgba(200,168,75,.45)}
.btn-dim{border-color:var(--border2);color:var(--textd)}
.btn-dim:hover{border-color:var(--text);color:var(--text)}
.btn-grn{border-color:var(--grn);color:var(--grn)}
.btn-grn:hover,.btn-grn.on{background:var(--grn);color:#000}
.btn-red{border-color:var(--red);color:var(--red)}
.btn-red:hover{background:var(--red);color:#fff}
.btn-sm{font-size:11px;padding:6px 14px;clip-path:polygon(5px 0%,100% 0%,calc(100% - 5px) 100%,0% 100%)}
.btn-row{display:flex;gap:10px;justify-content:flex-end;margin-top:22px}

/* â”€â”€ Panel â”€â”€ */
.panel{background:var(--panel);border:1px solid var(--border);padding:32px 36px;width:90vw;max-width:640px;max-height:88vh;overflow-y:auto}
.panel-lg{max-width:720px}
.panel-sm{max-width:480px}
.panel-title{font-family:var(--sans);font-size:26px;font-weight:900;letter-spacing:.08em;color:var(--gold);border-bottom:1px solid var(--border);padding-bottom:14px;margin-bottom:22px;text-transform:uppercase}
.section-label{font-family:var(--mono);font-size:10px;letter-spacing:.2em;color:var(--gold);margin-bottom:9px;text-transform:uppercase}

/* â”€â”€ Inputs â”€â”€ */
.inp{font-family:var(--mono);font-size:13px;padding:9px 11px;border:1px solid var(--border2);background:var(--bg2);color:var(--text);outline:none;width:100%;transition:border-color .12s;letter-spacing:.05em}
.inp:focus{border-color:var(--gold)}
.inp::placeholder{color:var(--textd)}
.inp-code{letter-spacing:.3em;font-size:18px;text-align:center;text-transform:uppercase}
.inp-group{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}

/* â”€â”€ Counter â”€â”€ */
.ctr{display:flex;align-items:center;gap:12px}
.ctr-btn{width:26px;height:26px;border:1px solid var(--border2);background:none;color:var(--gold);font-size:16px;cursor:pointer;font-family:var(--mono)}
.ctr-btn:hover{border-color:var(--gold);background:rgba(200,168,75,.1)}
.ctr-val{font-family:var(--sans);font-weight:900;font-size:26px;color:var(--gold);min-width:36px;text-align:center}

/* â”€â”€ Online Menu â”€â”€ */
.online-split{display:grid;grid-template-columns:1fr auto 1fr;gap:0;align-items:start}
.online-col{padding:0 20px;display:flex;flex-direction:column;gap:10px}
.online-col:first-child{padding-left:0}
.online-col:last-child{padding-right:0}
.online-div{width:1px;background:var(--border);margin:24px 0 0;align-self:stretch}
.or-label{font-family:var(--mono);font-size:10px;color:var(--dim);letter-spacing:.2em;padding:8px 12px;writing-mode:vertical-rl}

/* â”€â”€ Lobby â”€â”€ */
.lobby-code-row{display:flex;align-items:center;gap:14px;padding-bottom:18px;margin-bottom:18px;border-bottom:1px solid var(--border)}
.lobby-code-val{font-family:var(--mono);font-size:30px;font-weight:700;color:var(--gold2);letter-spacing:.35em}
.lobby-code-lbl{font-family:var(--mono);font-size:10px;color:var(--textd);letter-spacing:.15em}
.lobby-pl-header{display:flex;justify-content:space-between;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd);margin-bottom:7px}
.lobby-pl-list{min-height:90px;max-height:180px;overflow-y:auto;border:1px solid var(--border);padding:6px}
.pl-row{display:flex;align-items:center;gap:9px;padding:5px 7px;border-bottom:1px solid var(--border);font-family:var(--mono);font-size:11px}
.pl-row:last-child{border:none}
.pl-dot{width:9px;height:9px;flex-shrink:0;clip-path:polygon(2px 0%,100% 0%,calc(100% - 2px) 100%,0% 100%)}
.pl-name{flex:1;color:var(--text)}
.pl-ping{color:var(--textd);font-size:10px}
.pl-ready{font-size:10px}
.pl-ready.y{color:var(--grn)}
.pl-ready.n{color:var(--red)}
.pl-host{color:var(--gold);font-size:10px}
.lobby-settings-row{display:flex;align-items:center;gap:14px;margin-bottom:14px;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd)}
.status{font-family:var(--mono);font-size:10px;min-height:18px;margin-top:10px;letter-spacing:.1em}
.status.err{color:var(--red)}.status.ok{color:var(--grn)}.status.info{color:var(--gold)}

/* â”€â”€ Key Bindings â”€â”€ */
.bindings-wrap{display:flex;flex-direction:column;gap:10px;margin-bottom:20px}
.binding-group{border:1px solid var(--border);padding:12px 14px}
.binding-title{font-family:var(--mono);font-size:10px;letter-spacing:.2em;color:var(--gold);margin-bottom:9px}
.binding-grid{display:grid;grid-template-columns:60px 1fr;gap:6px;align-items:center}
.binding-lbl{font-family:var(--mono);font-size:10px;color:var(--textd)}
.key-btn{font-family:var(--mono);font-size:11px;padding:4px 9px;min-width:66px;border:1px solid var(--border2);background:var(--bg2);color:var(--text);cursor:pointer;text-align:center;transition:all .1s}
.key-btn.listening{border-color:var(--gold);color:var(--gold);animation:kpulse .7s infinite}
@keyframes kpulse{0%,100%{opacity:1}50%{opacity:.4}}
.player-count-row{display:flex;align-items:center;gap:18px;margin-bottom:20px;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd)}

/* â”€â”€ HUD â”€â”€ */
#screen-game{background:#000;justify-content:flex-start}
.hud{width:100%;height:38px;background:rgba(9,9,15,.96);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 14px;font-family:var(--mono);font-size:10px;letter-spacing:.1em;color:var(--textd);flex-shrink:0;gap:16px}
.hud-l{flex:1}.hud-c{flex:2;display:flex;justify-content:center;gap:18px;flex-wrap:wrap}.hud-r{flex:1;display:flex;justify-content:flex-end;gap:14px}
.hud-score{display:flex;align-items:center;gap:5px;font-size:11px}
.hud-dot{width:7px;height:7px;clip-path:polygon(2px 0,100% 0,calc(100% - 2px) 100%,0 100%)}
.hud-round{color:var(--gold);font-weight:700}
#game-canvas{display:block;width:100%;height:calc(100vh - 38px);background:#000}
.game-overlay{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(9,9,15,.93);border:2px solid var(--gold);padding:28px 60px;text-align:center;pointer-events:none}
.game-overlay.hidden{display:none}
.ov-title{font-family:var(--sans);font-size:44px;font-weight:900;color:var(--gold);letter-spacing:.06em}
.ov-sub{font-family:var(--mono);font-size:13px;color:var(--text);margin-top:6px;letter-spacing:.14em}

/* â”€â”€ Scoreboard â”€â”€ */
.score-list{margin-bottom:22px}
.score-row{display:flex;align-items:center;gap:14px;padding:11px 14px;border-bottom:1px solid var(--border)}
.score-row:last-child{border:none}
.score-rank{font-size:26px;font-weight:900;color:var(--textd);width:36px}
.score-rank.r1{color:var(--gold2)}
.score-bar{width:5px;height:34px;flex-shrink:0}
.score-name{flex:1;font-size:18px;font-weight:700;letter-spacing:.05em}
.score-kills{font-family:var(--mono);font-size:12px;color:var(--textd)}
.score-wins{font-family:var(--sans);font-weight:900;font-size:32px;color:var(--gold);min-width:50px;text-align:right}

/* â”€â”€ How to Play â”€â”€ */
.howto-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:24px}
.howto-sec h4{font-family:var(--mono);font-size:10px;color:var(--gold);letter-spacing:.2em;margin-bottom:8px}
.howto-sec p{font-size:13px;color:var(--text);line-height:1.6}
.ctrl-list{font-family:var(--mono);font-size:11px}
.ctrl-row-h{display:flex;align-items:center;gap:8px;margin-bottom:5px}
.pchip{padding:2px 6px;font-size:10px;font-weight:700;clip-path:polygon(3px 0,100% 0,calc(100% - 3px) 100%,0 100%)}

/* â”€â”€ Scrollbar â”€â”€ */
::-webkit-scrollbar{width:3px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border2)}
.hidden{display:none!important}

/* â”€â”€ Powerup notification toast â”€â”€ */
#pu-toast{position:fixed;top:50px;left:50%;transform:translateX(-50%);
  font-family:var(--mono);font-size:13px;letter-spacing:.15em;
  padding:6px 18px;border:1px solid;pointer-events:none;
  transition:opacity .3s;opacity:0;z-index:100}
#pu-toast.show{opacity:1}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MOBILE STYLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Landscape lock overlay */
#rotate-overlay{
  display:none;position:fixed;inset:0;z-index:9999;
  background:var(--bg);align-items:center;justify-content:center;
  flex-direction:column;gap:20px;
}
#rotate-overlay.show{display:flex;}
#rotate-overlay svg{animation:rotateSvg 2s ease-in-out infinite;}
@keyframes rotateSvg{0%,100%{transform:rotate(0deg);}50%{transform:rotate(90deg);}}
#rotate-overlay p{font-family:var(--mono);font-size:12px;letter-spacing:.2em;color:var(--gold);text-align:center;}

/* Mobile menu tweaks */
@media (max-width: 700px) {
  .title-main{font-size:clamp(44px,13vw,80px);}
  .title-sub{font-size:9px;letter-spacing:.12em;}
  .menu-btns{width:88vw;}
  .btn{font-size:13px;padding:13px 18px;}
  .panel{padding:20px 18px;max-height:92vh;}
  .panel-title{font-size:20px;}
  .howto-grid{grid-template-columns:1fr;}
  .online-split{grid-template-columns:1fr;gap:16px;}
  .online-div{display:none;}
  .score-row{padding:8px 10px;gap:10px;}
  .score-name{font-size:15px;}
  .score-wins{font-size:24px;}
  .hud{height:32px;padding:0 8px;font-size:9px;gap:8px;}
  .hud-c{gap:8px;flex-wrap:nowrap;overflow:hidden;}
  .hud-score{font-size:9px;}
  #game-canvas{height:calc(100vh - 32px);}
}

/* â”€â”€ Virtual controls overlay (shown only on touch devices in game) â”€â”€ */
#vcontrols{
  display:none;
  position:fixed;
  bottom:0;left:0;right:0;
  height:var(--vc-h, 200px);
  pointer-events:none;
  z-index:200;
}
#vcontrols.active{ display:block; }

/* Joystick zone â€” left third of screen */
#vjoy-zone{
  position:absolute;
  left:0;bottom:0;
  width:50%;height:100%;
  pointer-events:all;
}
#vjoy-base{
  position:absolute;
  width:110px;height:110px;
  border-radius:50%;
  background:rgba(255,255,255,0.06);
  border:2px solid rgba(255,255,255,0.18);
  transform:translate(-50%,-50%);
  pointer-events:none;
}
#vjoy-stick{
  position:absolute;
  width:46px;height:46px;
  border-radius:50%;
  background:rgba(200,168,75,0.55);
  border:2px solid rgba(200,168,75,0.9);
  transform:translate(-50%,-50%);
  pointer-events:none;
  box-shadow:0 0 12px rgba(200,168,75,0.4);
  transition:box-shadow .1s;
}

/* Fire button â€” right side */
#vfire-btn{
  position:absolute;
  right:28px;
  bottom:30px;
  width:80px;height:80px;
  border-radius:50%;
  background:rgba(232,84,58,0.25);
  border:3px solid rgba(232,84,58,0.8);
  pointer-events:all;
  display:flex;align-items:center;justify-content:center;
  font-family:var(--mono);font-size:11px;font-weight:700;
  letter-spacing:.12em;color:rgba(232,84,58,0.9);
  box-shadow:0 0 16px rgba(232,84,58,0.3);
  user-select:none;-webkit-user-select:none;
  touch-action:none;
}
#vfire-btn:active,#vfire-btn.pressed{
  background:rgba(232,84,58,0.6);
  box-shadow:0 0 28px rgba(232,84,58,0.7);
}

/* Leave game button (mobile) */
#vleave-btn{
  position:absolute;
  top:6px;right:8px;
  width:36px;height:36px;
  border-radius:50%;
  background:rgba(9,9,15,0.7);
  border:1px solid var(--border2);
  pointer-events:all;
  display:none;align-items:center;justify-content:center;
  font-size:16px;color:var(--textd);
  z-index:201;
}
@media (max-width:700px){
  #vleave-btn{display:flex;}
}

/* Joystick direction indicators */
#vjoy-dirs{
  position:absolute;
  width:110px;height:110px;
  transform:translate(-50%,-50%);
  pointer-events:none;
}
.vjoy-arrow{
  position:absolute;
  width:0;height:0;
  opacity:0.3;
}

/* Touch-friendly lobby */
@media (max-width:700px){
  .lobby-pl-list{max-height:140px;}
  .btn-row{flex-wrap:wrap;gap:8px;}
  #lobby-host-settings{flex-wrap:wrap;}
}

/* Prevent iOS bounce / context menu on canvas */
#game-canvas{
  touch-action:none;
  -webkit-touch-callout:none;
}
</style>
</head>
<body>
<div id="app">

<!-- â•â•â• SCREEN: MENU â•â•â• -->
<div id="screen-menu" class="screen active">
  <canvas id="bg-canvas"></canvas>
  <div class="menu-wrap">
    <div>
      <div class="title-eyebrow">Armored Combat System</div>
      <div class="title-main">TANK SIEGE</div>
      <div class="title-sub">MULTIPLAYER ARENA &nbsp;Â·&nbsp; BROWSER EDITION &nbsp;Â·&nbsp; WebRTC P2P</div>
    </div>
    <div class="menu-btns">
      <button class="btn btn-gold" id="btn-local">LOCAL MULTIPLAYER</button>
      <button class="btn btn-gold" id="btn-online">ONLINE MULTIPLAYER</button>
      <button class="btn btn-dim" id="btn-howto">HOW TO PLAY</button>
    </div>
    <div class="menu-footer">WebRTC DataChannels &nbsp;Â·&nbsp; Host-Authoritative &nbsp;Â·&nbsp; 60 Hz Fixed-Tick Simulation</div>
  </div>
</div>

<!-- â•â•â• SCREEN: HOW TO PLAY â•â•â• -->
<div id="screen-howto" class="screen">
  <div class="panel">
    <div class="panel-title">How to Play</div>
    <div class="howto-grid">
      <div class="howto-sec">
        <h4>Objective</h4>
        <p>Be the last tank alive each round. Bullets bounce off walls up to 5 times â€” including onto yourself. Scores track wins across rounds.</p>
      </div>
      <div class="howto-sec">
        <h4>Bullet Physics</h4>
        <p>Reflection uses R = V âˆ’ 2(VÂ·N)N. Each bullet starts with 5 bounce credits. Exceeding the limit destroys the bullet. Tanks have no health â€” one hit kills.</p>
      </div>
      <div class="howto-sec">
        <h4>Online Mode</h4>
        <p>Host creates lobby &amp; shares the 6-char join code. All game logic runs on the host. Clients send inputs only; the host runs the full simulation and sends state snapshots at ~20 Hz. Client-side prediction keeps it feeling smooth.</p>
      </div>
      <div class="howto-sec">
        <h4>Maze</h4>
        <p>Each round generates a new open-layout map: DFS skeleton plus aggressive wall removal creates wide corridors, open plazas, and looping paths. Much more open than a pure maze.</p>
      </div>
    </div>
    <div class="section-label" style="margin-bottom:10px;margin-top:4px">Powerups (spawn every 8s, last 8s)</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px 24px;margin-bottom:20px;font-family:var(--mono);font-size:11px">
      <div><span style="color:#ff6b35;font-weight:bold">âš¡ TRIPLE</span> â€” 3-way bullet spread</div>
      <div><span style="color:#42c8ff;font-weight:bold">â–¶â–¶ SPEED</span> â€” 2Ã— movement speed</div>
      <div><span style="color:#ff3366;font-weight:bold">ğŸ”¥ RAPID</span> â€” 3Ã— fire rate</div>
      <div><span style="color:#42c87a;font-weight:bold">ğŸ›¡ SHIELD</span> â€” absorb one bullet hit</div>
      <div><span style="color:#e84393;font-weight:bold">ğŸ’¥ HEAVY</span> â€” giant instant-kill bullets</div>
      <div><span style="color:#b06ae0;font-weight:bold">ğŸ‘» GHOST</span> â€” bullets pass through you</div>
      <div><span style="color:#ff8800;font-weight:bold">â†© RICO+</span> â€” bullets bounce 10 times</div>
      <div><span style="color:#88ddff;font-weight:bold">â„ FREEZE</span> â€” slow all other tanks</div>
    </div>
    <div class="howto-grid" style="grid-template-columns:1fr">
    </div>
    <div class="section-label" style="margin-bottom:12px">Default Controls</div>
    <div class="ctrl-list">
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p0);color:#fff">P1</span> W/S move Â· A/D rotate Â· Space fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p1);color:#fff">P2</span> â†‘/â†“ move Â· â†/â†’ rotate Â· Enter fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p2);color:#000">P3</span> T/G move Â· F/H rotate Â· R fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p3);color:#fff">P4</span> I/K move Â· J/L rotate Â· U fire</div>
    </div></div>
    <div class="btn-row"><button class="btn btn-dim" id="btn-howto-back">Back</button></div>
  </div>
</div>

<!-- â•â•â• SCREEN: LOCAL SETUP â•â•â• -->
<div id="screen-local" class="screen">
  <div class="panel panel-lg">
    <div class="panel-title">Local Multiplayer</div>
    <div class="player-count-row">
      <span>Players:</span>
      <div class="ctr">
        <button class="ctr-btn" id="local-dec">âˆ’</button>
        <span class="ctr-val" id="local-count">2</span>
        <button class="ctr-btn" id="local-inc">+</button>
      </div>
    </div>
    <div id="bindings-wrap" class="bindings-wrap"></div>
    <div class="btn-row">
      <button class="btn btn-dim" id="btn-local-back">Back</button>
      <button class="btn btn-gold" id="btn-local-start">Start Game</button>
    </div>
  </div>
</div>

<!-- â•â•â• SCREEN: ONLINE MENU â•â•â• -->
<div id="screen-online" class="screen">
  <div class="panel">
    <div class="panel-title">Online Multiplayer</div>
    <div class="online-split">
      <div class="online-col">
        <div class="section-label">Host a Game</div>
        <div class="inp-group">
          <input class="inp" id="host-name" placeholder="Your Name" maxlength="14">
        </div>
        <button class="btn btn-gold" id="btn-host">Create Lobby</button>
      </div>
      <div class="online-div"><span class="or-label">OR</span></div>
      <div class="online-col">
        <div class="section-label">Join a Game</div>
        <div class="inp-group">
          <input class="inp" id="join-name" placeholder="Your Name" maxlength="14">
          <input class="inp inp-code" id="join-code" placeholder="JOIN CODE" maxlength="6">
        </div>
        <button class="btn btn-gold" id="btn-join">Join Lobby</button>
      </div>
    </div>
    <div class="btn-row" style="margin-top:18px">
      <button class="btn btn-dim" id="btn-online-back">Back</button>
    </div>
    <div class="status info" id="online-status"></div>
  </div>
</div>

<!-- â•â•â• SCREEN: LOBBY â•â•â• -->
<div id="screen-lobby" class="screen">
  <div class="panel panel-sm">
    <div class="panel-title">Lobby</div>
    <div class="lobby-code-row">
      <div>
        <div class="lobby-code-lbl">Join Code</div>
        <div class="lobby-code-val" id="lobby-code-val">------</div>
      </div>
      <button class="btn btn-dim btn-sm" id="btn-copy-code">Copy</button>
    </div>
    <div id="lobby-host-settings" class="lobby-settings-row">
      <span>Max Players:</span>
      <div class="ctr">
        <button class="ctr-btn" id="lobby-max-dec">âˆ’</button>
        <span class="ctr-val" id="lobby-max-val" style="font-size:20px">8</span>
        <button class="ctr-btn" id="lobby-max-inc">+</button>
      </div>
    </div>
    <div class="lobby-pl-header"><span>Players</span><span id="lobby-pl-count">0/8</span></div>
    <div class="lobby-pl-list" id="lobby-pl-list" style="-webkit-overflow-scrolling:touch"></div>
    <div style="font-family:var(--mono);font-size:10px;color:var(--textd);margin:8px 0 2px" id="lobby-ping-row"></div>
    <div class="btn-row">
      <button class="btn btn-dim btn-sm" id="btn-lobby-leave">Leave</button>
      <button class="btn btn-grn btn-sm" id="btn-ready">Ready</button>
      <button class="btn btn-gold btn-sm hidden" id="btn-lobby-start">Start Game</button>
    </div>
    <div class="status" id="lobby-status"></div>
  </div>
</div>

<!-- â•â•â• SCREEN: GAME â•â•â• -->
<div id="screen-game" class="screen">
  <div class="hud">
    <div class="hud-l"><span class="hud-round" id="hud-round">Round 1</span></div>
    <div class="hud-c" id="hud-scores"></div>
    <div class="hud-r">
      <span id="hud-fps">FPS: â€”</span>
      <span id="hud-ping">PING: â€”</span>
    </div>
  </div>
  <canvas id="game-canvas"></canvas>
  <div class="game-overlay hidden" id="game-overlay">
    <div class="ov-title" id="ov-title">Round Over</div>
    <div class="ov-sub" id="ov-sub"></div>
  </div>
</div>

<!-- â•â•â• SCREEN: SCOREBOARD â•â•â• -->
<div id="screen-scoreboard" class="screen">
  <div class="panel">
    <div class="panel-title">Scoreboard</div>
    <div class="score-list" id="score-list"></div>
    <div class="btn-row">
      <button class="btn btn-dim" id="btn-score-menu">Main Menu</button>
      <button class="btn btn-gold" id="btn-score-next">Next Round</button>
    </div>
  </div>
</div>

  <!-- â•â•â• VIRTUAL CONTROLS (mobile touch) â•â•â• -->
  <div id="vcontrols">
    <!-- Left: joystick -->
    <div id="vjoy-zone">
      <div id="vjoy-base"></div>
      <div id="vjoy-stick"></div>
    </div>
    <!-- Right: fire button -->
    <div id="vfire-btn">FIRE</div>
  </div>

  <!-- Rotate-to-landscape overlay -->
  <div id="rotate-overlay">
    <svg width="64" height="64" viewBox="0 0 64 64" fill="none">
      <rect x="8" y="16" width="32" height="22" rx="3" stroke="#c8a84b" stroke-width="2.5"/>
      <rect x="24" y="10" width="22" height="32" rx="3" stroke="rgba(200,168,75,0.35)" stroke-width="2" stroke-dasharray="4 2"/>
      <path d="M52 20 L58 14 L58 26 Z" fill="#c8a84b"/>
    </svg>
    <p>ROTATE DEVICE<br>TO LANDSCAPE</p>
  </div>

  <!-- Mobile leave button (shown during game) -->
  <div id="vleave-btn" title="Leave game">âœ•</div>
</div><!-- #app -->
<div id="connecting-overlay" style="display:none;position:fixed;inset:0;background:rgba(9,9,15,.92);z-index:999;align-items:center;justify-content:center;flex-direction:column;gap:16px">
  <div style="font-family:'Courier New',monospace;font-size:13px;letter-spacing:.2em;color:#c8a84b" id="connecting-msg">CONNECTING...</div>
  <div style="width:200px;height:2px;background:#252840;overflow:hidden"><div id="conn-bar" style="height:100%;background:#c8a84b;width:0;transition:width .3s"></div></div>
</div>

<script>
"use strict";
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘  TANK SIEGE â€” Complete Source                                â•‘
// â•‘  Architecture:                                               â•‘
// â•‘  â€¢ Constants / Utils                                         â•‘
// â•‘  â€¢ RNG (seeded, deterministic)                               â•‘
// â•‘  â€¢ Maze generator (iterative DFS, fully connected)           â•‘
// â•‘  â€¢ Vec2 (2D vector math)                                     â•‘
// â•‘  â€¢ Physics (AABB sweep, circle-AABB, reflection)             â•‘
// â•‘  â€¢ Simulation (authoritative deterministic 60 Hz)            â•‘
// â•‘  â€¢ Packets (typed, validated)                                â•‘
// â•‘  â€¢ WebRTCHost (runs sim, broadcasts snapshots)               â•‘
// â•‘  â€¢ WebRTCClient (prediction, reconciliation, interpolation)  â•‘
// â•‘  â€¢ LocalGame (same-device multiplayer, same sim core)        â•‘
// â•‘  â€¢ Renderer (Canvas 2D, decoupled from sim)                  â•‘
// â•‘  â€¢ Particles                                                 â•‘
// â•‘  â€¢ KeyBindings                                               â•‘
// â•‘  â€¢ UI (screens, lobby, scoreboard)                           â•‘
// â•‘  â€¢ MenuBG (animated background)                              â•‘
// â•‘  â€¢ App (entry point / wiring)                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 1 â€” CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const C = Object.freeze({
  TICK_RATE: 60,
  TICK_MS: 1000 / 60,
  SNAP_RATE: 20,        // host snapshot broadcasts per second
  SNAP_INTERVAL: 3,     // send snapshot every N ticks (60/20=3)
  MAX_PLAYERS: 8,
  // World
  CELL: 64,             // px per maze cell (bigger = more open feel)
  COLS: 21,             // must be odd
  ROWS: 15,             // must be odd
  WALL_T: 4,            // wall render thickness (visual only, collision uses cell AABB)
  // Powerups
  PU_SPAWN_INTERVAL: 8,  // seconds between powerup spawns
  PU_RADIUS: 14,         // pickup collision radius
  PU_DURATION: 8,        // seconds powerup lasts
  PU_MAX: 5,             // max simultaneous powerups on map
  // Tank
  T_RADIUS: 13,
  T_SPEED: 110,         // px/s
  T_ROT: 2.8,           // rad/s
  T_FIRE_CD: 0.45,      // seconds
  T_BARREL: 17,         // turret length px
  // Bullet
  B_RADIUS: 4,
  B_SPEED: 300,         // px/s
  B_BOUNCES: 5,
  B_LIFE: 7,            // seconds max lifetime
  // Net
  PING_INTERVAL: 1500,
  TIMEOUT: 7000,
  // Packet type IDs
  PKT: {
    LOBBY_STATE: 1, GAME_START: 2, SNAPSHOT: 3,
    ROUND_END: 4, KICK: 5, PONG: 6,
    JOIN: 10, INPUT: 11, READY: 12, PING: 13,
  },
  // Player colors
  COLORS: ['#e8543a','#4a9fd4','#42c87a','#b06ae0','#e8c870','#d44a88','#42c8c8','#ff8c42'],
  // Default key bindings [up, down, left, right, fire]
  DEFAULT_KEYS: [
    ['KeyW','KeyS','KeyA','KeyD','Space'],
    ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter'],
    ['KeyT','KeyG','KeyF','KeyH','KeyR'],
    ['KeyI','KeyK','KeyJ','KeyL','KeyU'],
  ],
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 2 â€” UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Utils = {
  genCode() {
    const ch = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    return Array.from({length:6}, () => ch[Math.floor(Math.random()*ch.length)]).join('');
  },
  genId() { return Math.random().toString(36).slice(2,10).toUpperCase(); },
  clamp(v,lo,hi) { return Math.max(lo, Math.min(hi, v)); },
  lerp(a,b,t) { return a + (b-a)*t; },
  lerpAngle(a,b,t) {
    let d = b - a;
    while (d > Math.PI) d -= 2*Math.PI;
    while (d < -Math.PI) d += 2*Math.PI;
    return a + d*t;
  },
  encode(obj) { return JSON.stringify(obj); },
  decode(data) {
    try { return JSON.parse(typeof data === 'string' ? data : new TextDecoder().decode(data)); }
    catch { return null; }
  },
  now() { return performance.now(); },
  keyName(code) {
    const m = {Space:'SPC',Enter:'ENT',ArrowUp:'â†‘',ArrowDown:'â†“',ArrowLeft:'â†',ArrowRight:'â†’',
      ShiftLeft:'LSFT',ShiftRight:'RSFT',ControlLeft:'LCTL',ControlRight:'RCTL'};
    if (m[code]) return m[code];
    if (code.startsWith('Key')) return code.slice(3);
    if (code.startsWith('Digit')) return code.slice(5);
    if (code.startsWith('Numpad')) return 'N'+code.slice(6);
    return code.slice(0,5);
  },
  deepClone(o) { return JSON.parse(JSON.stringify(o)); },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 3 â€” SEEDED RNG (Mulberry32)
// All randomness in simulation goes through this for determinism
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class RNG {
  constructor(seed=0) { this.s = seed >>> 0; }
  next() {
    let t = (this.s += 0x6D2B79F5) >>> 0;
    t = Math.imul(t ^ t>>>15, t | 1) >>> 0;
    t ^= t + Math.imul(t ^ t>>>7, t | 61) >>> 0;
    this.s = t;
    return ((t ^ t>>>14) >>> 0) / 4294967296;
  }
  int(lo,hi) { return lo + Math.floor(this.next() * (hi-lo+1)); }
  shuffle(arr) {
    for (let i=arr.length-1; i>0; i--) {
      const j = this.int(0,i);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }
  static fromTime() { return new RNG(Date.now() & 0xFFFFFFFF); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 4 â€” MAZE GENERATOR
// Hybrid approach: DFS skeleton + aggressive wall removal for open feel.
// After generating a perfect maze we knock out extra walls to create
// larger rooms, loops, and wide corridors. Much more playable than
// a pure perfect maze (which produces only narrow single-width corridors).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Maze {
  static generate(rng, cols=C.COLS, rows=C.ROWS, cell=C.CELL) {
    const grid = Array.from({length:rows}, () => new Uint8Array(cols));
    const W = cols*cell, H = rows*cell;

    // Step 1: DFS perfect maze skeleton
    grid[1][1] = 1;
    const stack = [{c:1,r:1}];
    const dirs4 = [{dc:2,dr:0},{dc:-2,dr:0},{dc:0,dr:2},{dc:0,dr:-2}];
    while (stack.length) {
      const cur = stack[stack.length-1];
      const shuffled = rng.shuffle([...dirs4]);
      let advanced = false;
      for (const d of shuffled) {
        const nc=cur.c+d.dc, nr=cur.r+d.dr;
        if (nc>0&&nc<cols-1&&nr>0&&nr<rows-1&&!grid[nr][nc]) {
          grid[nr][nc] = 1;
          grid[cur.r+d.dr/2][cur.c+d.dc/2] = 1;
          stack.push({c:nc,r:nr});
          advanced = true;
          break;
        }
      }
      if (!advanced) stack.pop();
    }

    // Step 2: Knock out ~55% of interior walls to create open areas.
    // We only remove even-row/col cells (the wall cells between rooms).
    // This creates loops, wide corridors and open plazas.
    const wallCells = [];
    for (let r=1;r<rows-1;r++) {
      for (let c=1;c<cols-1;c++) {
        if (!grid[r][c]) wallCells.push({r,c});
      }
    }
    rng.shuffle(wallCells);
    const removeCount = Math.floor(wallCells.length * 0.55);
    for (let i=0;i<removeCount;i++) {
      const {r,c} = wallCells[i];
      // Only remove if it doesn't isolate a cell (keep border intact)
      if (r>0&&r<rows-1&&c>0&&c<cols-1) grid[r][c] = 1;
    }

    // Step 3: Create 2â€“4 large open rooms by clearing 3Ã—3 blocks
    const numRooms = rng.int(2,4);
    for (let room=0;room<numRooms;room++) {
      const rc = rng.int(2, rows-4);
      const cc = rng.int(2, cols-4);
      for (let dr=0;dr<3;dr++)
        for (let dc=0;dc<3;dc++)
          if (rc+dr>0&&rc+dr<rows-1&&cc+dc>0&&cc+dc<cols-1)
            grid[rc+dr][cc+dc] = 1;
    }

    // Step 4: Restore hard border walls
    for(let c=0;c<cols;c++){grid[0][c]=0;grid[rows-1][c]=0;}
    for(let r=0;r<rows;r++){grid[r][0]=0;grid[r][cols-1]=0;}

    // Build AABB wall list
    const walls = [];
    for (let r=0;r<rows;r++)
      for (let c=0;c<cols;c++)
        if (!grid[r][c]) walls.push({x:c*cell, y:r*cell, w:cell, h:cell});

    // Open cells for rendering
    const open = [];
    for (let r=0;r<rows;r++)
      for (let c=0;c<cols;c++)
        if (grid[r][c]) open.push({x:c*cell, y:r*cell, w:cell, h:cell});

    // Spawn points: all open cells, shuffled
    const spawns = [];
    for (let r=1;r<rows-1;r+=2)
      for (let c=1;c<cols-1;c+=2)
        if (grid[r][c]) spawns.push({x:c*cell+cell/2, y:r*cell+cell/2});
    // Also add some even-coord open cells for more spawn variety
    for (let r=2;r<rows-2;r+=3)
      for (let c=2;c<cols-2;c+=3)
        if (grid[r][c]) spawns.push({x:c*cell+cell/2, y:r*cell+cell/2});
    rng.shuffle(spawns);

    // Powerup spawn locations: open cells away from borders
    const puSpawns = [];
    for (let r=2;r<rows-2;r++)
      for (let c=2;c<cols-2;c++)
        if (grid[r][c]) puSpawns.push({x:c*cell+cell/2, y:r*cell+cell/2});
    rng.shuffle(puSpawns);

    return {cols, rows, cell, W, H, walls, open, spawns, puSpawns, grid};
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 5 â€” VEC2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Vec2 {
  constructor(x=0,y=0){this.x=x;this.y=y;}
  add(v){return new Vec2(this.x+v.x,this.y+v.y);}
  sub(v){return new Vec2(this.x-v.x,this.y-v.y);}
  scale(s){return new Vec2(this.x*s,this.y*s);}
  dot(v){return this.x*v.x+this.y*v.y;}
  len(){return Math.hypot(this.x,this.y);}
  norm(){const l=this.len();return l?this.scale(1/l):new Vec2();}
  reflect(n){const d=this.dot(n)*2;return new Vec2(this.x-d*n.x,this.y-d*n.y);}
  rot(a){const c=Math.cos(a),s=Math.sin(a);return new Vec2(this.x*c-this.y*s,this.x*s+this.y*c);}
  static ang(a){return new Vec2(Math.cos(a),Math.sin(a));}
  distSq(v){return (this.x-v.x)**2+(this.y-v.y)**2;}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 6 â€” PHYSICS
// All functions are pure (no mutation of game state externally)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Physics = {
  // Resolve circle vs AABB wall list â€” returns {x,y,hit}
  circleWalls(x,y,r,walls) {
    let hit=false;
    for (const w of walls) {
      const cx=Utils.clamp(x, w.x, w.x+w.w);
      const cy=Utils.clamp(y, w.y, w.y+w.h);
      const dx=x-cx, dy=y-cy;
      const d2=dx*dx+dy*dy;
      if (d2 < r*r && d2 > 1e-10) {
        const d=Math.sqrt(d2), ov=r-d;
        x += (dx/d)*ov; y += (dy/d)*ov;
        hit=true;
      }
    }
    return {x,y,hit};
  },

  // Resolve all tank-tank circle overlaps (modifies array in place)
  tankTank(tanks) {
    const minD2 = (C.T_RADIUS*2)**2;
    for (let i=0;i<tanks.length;i++) {
      if(tanks[i].dead) continue;
      for (let j=i+1;j<tanks.length;j++) {
        if(tanks[j].dead) continue;
        const dx=tanks[j].x-tanks[i].x, dy=tanks[j].y-tanks[i].y;
        const d2=dx*dx+dy*dy;
        if (d2 < minD2 && d2 > 1e-10) {
          const d=Math.sqrt(d2), ov=(C.T_RADIUS*2-d)/2;
          const nx=dx/d, ny=dy/d;
          tanks[i].x -= nx*ov; tanks[i].y -= ny*ov;
          tanks[j].x += nx*ov; tanks[j].y += ny*ov;
        }
      }
    }
  },

  // Sweep moving circle vs AABB â€” returns {t, nx, ny} or null
  sweepCircleAABB(cx,cy,vx,vy,r,w,dt) {
    // Expand AABB by r (Minkowski sum)
    const ex=w.x-r, ey=w.y-r, ew=w.w+r*2, eh=w.h+r*2;
    let tmin=0, tmax=dt;
    let nnx=0, nny=0;
    // X slab
    if (Math.abs(vx)<1e-9) {
      if (cx<ex||cx>ex+ew) return null;
    } else {
      let t1=(ex-cx)/vx, t2=(ex+ew-cx)/vx;
      let nx1=-1,nx2=1;
      if(t1>t2){[t1,t2]=[t2,t1];[nx1,nx2]=[nx2,nx1];}
      if(t1>tmin){tmin=t1;nnx=nx1;nny=0;}
      tmax=Math.min(tmax,t2);
      if(tmin>tmax) return null;
    }
    // Y slab
    if (Math.abs(vy)<1e-9) {
      if (cy<ey||cy>ey+eh) return null;
    } else {
      let t1=(ey-cy)/vy, t2=(ey+eh-cy)/vy;
      let ny1=-1,ny2=1;
      if(t1>t2){[t1,t2]=[t2,t1];[ny1,ny2]=[ny2,ny1];}
      if(t1>tmin){tmin=t1;nnx=0;nny=ny1;}
      tmax=Math.min(tmax,t2);
      if(tmin>tmax) return null;
    }
    if(tmin<0||tmin>dt) return null;
    return {t:tmin, nx:nnx, ny:nny};
  },

  // Move bullet with wall bouncing â€” returns updated bullet or null if destroyed
  moveBullet(b, walls, dt) {
    let {x,y,vx,vy,bounces,maxB} = b;
    let rem = dt;
    for (let iter=0;iter<8&&rem>1e-6;iter++) {
      let tmin=rem, tnx=0, tny=0, hitWall=false;
      for (const w of walls) {
        const res = Physics.sweepCircleAABB(x,y,vx,vy,C.B_RADIUS,w,rem);
        if(res && res.t < tmin) { tmin=res.t; tnx=res.nx; tny=res.ny; hitWall=true; }
      }
      x += vx*tmin; y += vy*tmin; rem -= tmin;
      if (hitWall) {
        bounces++;
        if (bounces > maxB) return null; // destroyed
        // Reflect: R = V - 2(VÂ·N)N
        const n = new Vec2(tnx, tny);
        const v = new Vec2(vx, vy);
        const rf = v.reflect(n);
        vx=rf.x; vy=rf.y;
        // Epsilon push off wall
        x += vx*0.001; y += vy*0.001;
      }
    }
    return {...b, x, y, vx, vy, bounces};
  },

  // Simple circle-circle bullet/tank overlap (big bullets have 2.5x radius)
  bulletTank(b, t) {
    if(t.dead) return false;
    const dx=b.x-t.x, dy=b.y-t.y;
    const br = b.big ? C.B_RADIUS*2.5 : C.B_RADIUS;
    return dx*dx+dy*dy < (br+C.T_RADIUS)**2;
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 6.5 â€” POWERUP DEFINITIONS
// Each powerup type: id, label, color, icon char, duration,
// and effect applied in simulation tick.
//
// Offensive: TRIPLE_SHOT, FAST_FIRE, LASER, MINE
// Defensive: SPEED_BOOST, SHIELD, GHOST, RICOCHET+
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const POWERUP_TYPES = [
  // â”€â”€ Offensive â”€â”€
  {
    id: 'TRIPLE_SHOT', label: 'TRIPLE', color: '#ff6b35', icon: 'âš¡',
    desc: 'Fires 3 bullets in a spread',
    apply(tank) { tank.pu_tripleShot = C.PU_DURATION; },
  },
  {
    id: 'FAST_FIRE', label: 'RAPID', color: '#ff3366', icon: 'ğŸ”¥',
    desc: 'Fire rate tripled',
    apply(tank) { tank.pu_fastFire = C.PU_DURATION; },
  },
  {
    id: 'BIG_BULLET', label: 'HEAVY', color: '#e84393', icon: 'ğŸ’¥',
    desc: 'Giant bullets, instant kill',
    apply(tank) { tank.pu_bigBullet = C.PU_DURATION; },
  },
  {
    id: 'EXTRA_BOUNCE', label: 'RICO+', color: '#ff8800', icon: 'â†©',
    desc: 'Bullets bounce 10 times',
    apply(tank) { tank.pu_extraBounce = C.PU_DURATION; },
  },
  // â”€â”€ Defensive â”€â”€
  {
    id: 'SPEED', label: 'SPEED', color: '#42c8ff', icon: 'â–¶â–¶',
    desc: 'Move 2Ã— faster',
    apply(tank) { tank.pu_speed = C.PU_DURATION; },
  },
  {
    id: 'SHIELD', label: 'SHIELD', color: '#42c87a', icon: 'ğŸ›¡',
    desc: 'Absorbs one bullet hit',
    apply(tank) { tank.pu_shield = 1; },  // shield charge count
  },
  {
    id: 'GHOST', label: 'GHOST', color: '#b06ae0', icon: 'ğŸ‘»',
    desc: 'Bullets pass through you',
    apply(tank) { tank.pu_ghost = C.PU_DURATION; },
  },
  {
    id: 'FREEZE', label: 'FREEZE', color: '#88ddff', icon: 'â„',
    desc: 'All other tanks briefly slowed',
    apply(tank, allTanks) {
      for (const t of allTanks) {
        if (t.id !== tank.id && !t.dead) t.pu_frozen = 2.5;
      }
    },
  },
];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 7 â€” SIMULATION
// Authoritative, deterministic. Runs on host at 60 Hz.
// Also used by clients as shadow-sim for prediction.
//
// State:
//   tick: number
//   tanks: [{id,name,color,x,y,angle,dead,kills,fireCd, pu_*}]
//   bullets: [{id,ownerId,x,y,vx,vy,bounces,maxB,life,big}]
//   powerups: [{id,type,x,y,collected}]
//   roundOver: bool
//   winnerId: string|null
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Simulation {
  constructor() {
    this.maze = null;
    this.state = null;
    this._bid = 0;
  }

  init(players, maze) {
    this.maze = maze;
    this._bid = 0;
    this._puid = 0;
    this._puTimer = 0; // accumulates seconds until next powerup spawn
    this.state = {
      tick: 0,
      tanks: players.map((p,i) => ({
        id: p.id, name: p.name,
        color: C.COLORS[i % C.COLORS.length],
        x: maze.spawns[i % maze.spawns.length].x,
        y: maze.spawns[i % maze.spawns.length].y,
        angle: Math.PI * 0.25,
        dead: false, kills: 0, fireCd: 0,
        // powerup state fields (null/0 = inactive)
        pu_tripleShot:0, pu_fastFire:0, pu_bigBullet:0, pu_extraBounce:0,
        pu_speed:0, pu_shield:0, pu_ghost:0, pu_frozen:0,
        activePu: null, // current display label
      })),
      bullets: [],
      powerups: [],  // active pickups on the map
      roundOver: false,
      winnerId: null,
    };
  }

  // Apply one batch of inputs (Map<id, inputState>) and advance tick
  tick(inputs) {
    if (!this.state || this.state.roundOver) return;
    const s = this.state;
    const dt = 1 / C.TICK_RATE;

    // 0. Tick powerup timers
    this._tickPowerupTimers(s, dt);

    // 1. Spawn powerups on a timer
    this._puTimer += dt;
    if (this._puTimer >= C.PU_SPAWN_INTERVAL && s.powerups.length < C.PU_MAX) {
      this._puTimer = 0;
      this._spawnPowerup(s);
    }

    // 2. Apply inputs â†’ move / fire
    for (const t of s.tanks) {
      if (t.dead) continue;
      const inp = inputs ? (inputs.get ? inputs.get(t.id) : inputs[t.id]) : null;
      if (inp) {
        const frozen = t.pu_frozen > 0;
        if (!frozen) {
          if (inp.left)  t.angle -= C.T_ROT * dt;
          if (inp.right) t.angle += C.T_ROT * dt;
          if (inp.up || inp.down) {
            const speedMult = t.pu_speed > 0 ? 2.0 : 1.0;
            const spd = inp.up ? C.T_SPEED * speedMult : -C.T_SPEED * speedMult;
            t.x += Math.cos(t.angle) * spd * dt;
            t.y += Math.sin(t.angle) * spd * dt;
          }
        }
        // Fire (fast fire = 3x fire rate)
        const fireCdBase = t.pu_fastFire > 0 ? C.T_FIRE_CD / 3 : C.T_FIRE_CD;
        if (inp.fire && t.fireCd <= 0 && !frozen) {
          if (t.pu_tripleShot > 0) {
            this._fireBullet(t, -0.25);
            this._fireBullet(t, 0);
            this._fireBullet(t, 0.25);
          } else {
            this._fireBullet(t, 0);
          }
          t.fireCd = fireCdBase;
        }
      }
      t.fireCd = Math.max(0, t.fireCd - dt);
    }

    // 3. Resolve tank-wall collisions
    for (const t of s.tanks) {
      if (t.dead) continue;
      const r = Physics.circleWalls(t.x, t.y, C.T_RADIUS, this.maze.walls);
      t.x = r.x; t.y = r.y;
    }

    // 4. Resolve tank-tank
    Physics.tankTank(s.tanks);
    for (const t of s.tanks) {
      if (t.dead) continue;
      const r = Physics.circleWalls(t.x, t.y, C.T_RADIUS, this.maze.walls);
      t.x = r.x; t.y = r.y;
    }

    // 5. Check powerup pickups
    for (const pu of s.powerups) {
      if (pu.collected) continue;
      for (const t of s.tanks) {
        if (t.dead) continue;
        const dx = t.x - pu.x, dy = t.y - pu.y;
        if (dx*dx + dy*dy < (C.T_RADIUS + C.PU_RADIUS)**2) {
          pu.collected = true;
          const puType = POWERUP_TYPES.find(p=>p.id===pu.type);
          if (puType) {
            puType.apply(t, s.tanks);
            t.activePu = puType.label;
          }
          break;
        }
      }
    }
    s.powerups = s.powerups.filter(p=>!p.collected);

    // 6. Move bullets
    const newBullets = [];
    for (const b of s.bullets) {
      b.life -= dt;
      if (b.life <= 0) continue;
      const nb = Physics.moveBullet(b, this.maze.walls, dt);
      if (!nb) continue;
      Object.assign(b, nb);

      // 7. Bullet-tank collision
      let hitSomething = false;
      for (const t of s.tanks) {
        if (t.pu_ghost > 0) continue; // ghost: bullets pass through
        if (Physics.bulletTank(b, t)) {
          // Shield absorbs one hit
          if (t.pu_shield > 0) {
            t.pu_shield--;
            if (t.pu_shield <= 0) t.activePu = null;
            hitSomething = true; // bullet is consumed
          } else {
            t.dead = true;
            hitSomething = true;
            if (b.ownerId !== t.id) {
              const shooter = s.tanks.find(tt=>tt.id===b.ownerId);
              if (shooter && !shooter.dead) shooter.kills++;
            }
          }
          break;
        }
      }
      if (!hitSomething) newBullets.push(b);
    }
    s.bullets = newBullets;

    // 8. Check round end
    const alive = s.tanks.filter(t=>!t.dead);
    if (alive.length <= 1 && s.tanks.length > 1) {
      s.roundOver = true;
      s.winnerId = alive.length === 1 ? alive[0].id : null;
    }
    if (s.tanks.length === 1) s.roundOver = false;

    s.tick++;
  }

  _tickPowerupTimers(s, dt) {
    for (const t of s.tanks) {
      if (t.pu_tripleShot > 0) { t.pu_tripleShot -= dt; if(t.pu_tripleShot<=0){t.pu_tripleShot=0;t.activePu=null;} }
      if (t.pu_fastFire > 0)   { t.pu_fastFire -= dt;   if(t.pu_fastFire<=0){t.pu_fastFire=0;if(!t.activePu||t.activePu==='RAPID')t.activePu=null;} }
      if (t.pu_bigBullet > 0)  { t.pu_bigBullet -= dt;  if(t.pu_bigBullet<=0){t.pu_bigBullet=0;} }
      if (t.pu_extraBounce > 0){ t.pu_extraBounce -= dt; if(t.pu_extraBounce<=0)t.pu_extraBounce=0; }
      if (t.pu_speed > 0)      { t.pu_speed -= dt;       if(t.pu_speed<=0){t.pu_speed=0;} }
      if (t.pu_ghost > 0)      { t.pu_ghost -= dt;       if(t.pu_ghost<=0){t.pu_ghost=0;} }
      if (t.pu_frozen > 0)     { t.pu_frozen -= dt;      if(t.pu_frozen<=0)t.pu_frozen=0; }
      // Recompute activePu label (pick highest priority active one)
      if (!t.dead) {
        if (t.pu_tripleShot>0) t.activePu='TRIPLE';
        else if (t.pu_fastFire>0) t.activePu='RAPID';
        else if (t.pu_bigBullet>0) t.activePu='HEAVY';
        else if (t.pu_extraBounce>0) t.activePu='RICO+';
        else if (t.pu_speed>0) t.activePu='SPEED';
        else if (t.pu_shield>0) t.activePu='SHIELD';
        else if (t.pu_ghost>0) t.activePu='GHOST';
        else if (t.pu_frozen>0) {} // frozen is received, show nothing
        else t.activePu=null;
      }
    }
  }

  _spawnPowerup(s) {
    if (!this.maze.puSpawns || this.maze.puSpawns.length === 0) return;
    // Pick a random spawn point not too close to any tank
    const candidates = this.maze.puSpawns.filter(sp => {
      for (const t of s.tanks) {
        if (t.dead) continue;
        const dx=t.x-sp.x, dy=t.y-sp.y;
        if (dx*dx+dy*dy < (C.CELL*2)**2) return false;
      }
      return true;
    });
    if (candidates.length === 0) return;
    const sp = candidates[Math.floor(Math.random() * candidates.length)];
    const typeIdx = Math.floor(Math.random() * POWERUP_TYPES.length);
    s.powerups.push({
      id: `pu${++this._puid}`,
      type: POWERUP_TYPES[typeIdx].id,
      x: sp.x, y: sp.y,
      collected: false,
    });
  }

  _fireBullet(tank, angleOffset=0) {
    const a = tank.angle + angleOffset;
    const tx = tank.x + Math.cos(a)*C.T_BARREL;
    const ty = tank.y + Math.sin(a)*C.T_BARREL;
    const big = tank.pu_bigBullet > 0;
    const maxB = tank.pu_extraBounce > 0 ? 10 : C.B_BOUNCES;
    this.state.bullets.push({
      id: `b${++this._bid}`,
      ownerId: tank.id,
      x: tx, y: ty,
      vx: Math.cos(a)*C.B_SPEED,
      vy: Math.sin(a)*C.B_SPEED,
      bounces: 0, maxB,
      life: C.B_LIFE,
      big, // big bullets have larger collision radius
    });
  }

  serialize() {
    const s = this.state;
    return {
      tick: s.tick,
      tanks: s.tanks.map(t=>({
        id:t.id,x:t.x,y:t.y,angle:t.angle,
        dead:t.dead,kills:t.kills,fireCd:t.fireCd,
        pu_tripleShot:t.pu_tripleShot||0, pu_fastFire:t.pu_fastFire||0,
        pu_bigBullet:t.pu_bigBullet||0, pu_extraBounce:t.pu_extraBounce||0,
        pu_speed:t.pu_speed||0, pu_shield:t.pu_shield||0,
        pu_ghost:t.pu_ghost||0, pu_frozen:t.pu_frozen||0,
        activePu:t.activePu||null,
      })),
      bullets: s.bullets.map(b=>({
        id:b.id,ownerId:b.ownerId,
        x:b.x,y:b.y,vx:b.vx,vy:b.vy,
        bounces:b.bounces,maxB:b.maxB,life:b.life,big:b.big||false,
      })),
      powerups: s.powerups.map(p=>({id:p.id,type:p.type,x:p.x,y:p.y})),
      roundOver: s.roundOver,
      winnerId: s.winnerId,
    };
  }

  applySnapshot(snap) {
    if (!this.state) return;
    const s = this.state;
    s.tick = snap.tick;
    s.roundOver = snap.roundOver;
    s.winnerId = snap.winnerId;
    for (const st of snap.tanks) {
      const t = s.tanks.find(tt=>tt.id===st.id);
      if (t) Object.assign(t, st);
    }
    s.bullets = snap.bullets.map(b=>({...b}));
    s.powerups = (snap.powerups||[]).map(p=>({...p, collected:false}));
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 8 â€” PACKETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Pkt = {
  make: (type, data={}) => ({type, ...data}),
  validate(p) {
    if (!p || typeof p !== 'object') return false;
    if (typeof p.type !== 'number') return false;
    return Object.values(C.PKT).includes(p.type);
  },
  validateInput(p) {
    return Pkt.validate(p) && p.type===C.PKT.INPUT
      && typeof p.playerId==='string'
      && typeof p.tick==='number'
      && p.inp && typeof p.inp==='object';
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 9 â€” WEBRTC HOST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class WebRTCHost {
  constructor(onEvent) {
    this._onEvent = onEvent; // callback(type, data)
    this._peer = null;
    this._clients = new Map(); // playerId â†’ {conn, name, ready, ping, lastSeen}
    this._lobbyCode = '';
    this._maxPlayers = 8;
    this._sim = null;
    this._maze = null;
    this._gameRunning = false;
    this._tickLoop = null;
    this._tick = 0;
    this._scores = new Map(); // playerId â†’ wins
    this._round = 1;
    this._pingTimer = null;
    this._snapAccum = 0;
    // Host's own player info
    this._hostId = Utils.genId();
    this._hostName = 'Host';
    this._hostInput = {up:false,down:false,left:false,right:false,fire:false};
  }

  get hostId() { return this._hostId; }

  async createLobby(hostName) {
    this._hostName = hostName || 'Host';
    this._lobbyCode = Utils.genCode();
    this._scores.set(this._hostId, 0);

    return new Promise((resolve, reject) => {
      // PeerJS peer ID = "TS_" + lobbyCode  so clients can find us
      const peerId = 'TS_' + this._lobbyCode;
      this._peer = new Peer(peerId, {
        host: '0.peerjs.com', port: 443, secure: true, path: '/',
        config: {
          iceServers: [
            {urls:'stun:stun.l.google.com:19302'},
            {urls:'stun:stun1.l.google.com:19302'},
          ]
        },
        debug: 0,
      });

      this._peer.on('open', id => {
        this._onEvent('lobby_created', {code: this._lobbyCode, hostId: this._hostId});
        resolve(this._lobbyCode);
      });

      this._peer.on('connection', conn => {
        this._handleConnection(conn);
      });

      this._peer.on('error', err => {
        // If peer ID taken, try with random suffix
        if (err.type === 'unavailable-id') {
          this._lobbyCode = Utils.genCode();
          const newPeer = new Peer('TS_'+this._lobbyCode, {
            host:'0.peerjs.com',port:443,secure:true,path:'/',
            config:{iceServers:[{urls:'stun:stun.l.google.com:19302'}]},
            debug:0,
          });
          newPeer.on('open', () => {
            this._peer.destroy();
            this._peer = newPeer;
            this._peer.on('connection', conn => this._handleConnection(conn));
            this._onEvent('lobby_created', {code: this._lobbyCode, hostId: this._hostId});
            resolve(this._lobbyCode);
          });
          newPeer.on('error', e2 => reject(e2));
          newPeer.on('connection', conn => this._handleConnection(conn));
        } else {
          reject(err);
        }
      });

      this._peer.on('disconnected', () => {
        this._peer.reconnect();
      });
    });
  }

  _handleConnection(conn) {
    conn.on('open', () => {
      conn.on('data', raw => this._onData(conn, raw));
      conn.on('close', () => this._onDisconnect(conn));
      conn.on('error', () => this._onDisconnect(conn));
    });
  }

  _onData(conn, raw) {
    const pkt = Utils.decode(raw);
    if (!pkt || !Pkt.validate(pkt)) return;

    const P = C.PKT;
    switch (pkt.type) {
      case P.JOIN: this._handleJoin(conn, pkt); break;
      case P.READY: this._handleReady(conn, pkt); break;
      case P.INPUT: this._handleInput(conn, pkt); break;
      case P.PING: this._handlePing(conn, pkt); break;
    }
  }

  _handleJoin(conn, pkt) {
    if (!pkt.playerId || !pkt.name) return;
    if (this._clients.size >= this._maxPlayers - 1) {
      conn.send(Utils.encode(Pkt.make(C.PKT.KICK, {reason:'Lobby full'})));
      return;
    }
    if (this._gameRunning) {
      conn.send(Utils.encode(Pkt.make(C.PKT.KICK, {reason:'Game in progress'})));
      return;
    }

    const id = pkt.playerId.slice(0,12);
    this._clients.set(id, {
      conn, name: pkt.name.slice(0,14), ready: false,
      ping: -1, lastSeen: Utils.now(),
      input: {up:false,down:false,left:false,right:false,fire:false},
    });
    if (!this._scores.has(id)) this._scores.set(id, 0);

    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  _handleReady(conn, pkt) {
    const cl = this._findClient(conn);
    if (!cl) return;
    cl.ready = pkt.isReady;
    cl.lastSeen = Utils.now();
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  _handleInput(conn, pkt) {
    if (!Pkt.validateInput(pkt)) return;
    const cl = this._findClient(conn);
    if (!cl) return;
    cl.lastSeen = Utils.now();
    cl.input = pkt.inp;
  }

  _handlePing(conn, pkt) {
    const cl = this._findClient(conn);
    if (cl) {
      cl.lastSeen = Utils.now();
      const now = Utils.now();
      cl.ping = now - (pkt.clientTime||now);
    }
    conn.send(Utils.encode(Pkt.make(C.PKT.PONG, {clientTime: pkt.clientTime, serverTime: Utils.now()})));
  }

  _onDisconnect(conn) {
    const entry = [...this._clients.entries()].find(([,v])=>v.conn===conn);
    if (!entry) return;
    this._clients.delete(entry[0]);
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
    this._onEvent('player_left', {id: entry[0]});
  }

  _findClient(conn) {
    return [...this._clients.values()].find(c=>c.conn===conn) || null;
  }

  _getLobbyData() {
    const players = [
      {id:this._hostId, name:this._hostName, ready:true, ping:-1, isHost:true, color:C.COLORS[0]},
      ...[...this._clients.entries()].map(([id,cl],i)=>({
        id, name:cl.name, ready:cl.ready, ping:cl.ping, isHost:false,
        color:C.COLORS[(i+1)%C.COLORS.length],
      })),
    ];
    return {players, maxPlayers:this._maxPlayers, code:this._lobbyCode};
  }

  _broadcastLobbyState() {
    const data = this._getLobbyData();
    const pkt = Utils.encode(Pkt.make(C.PKT.LOBBY_STATE, data));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }
  }

  setMaxPlayers(n) {
    this._maxPlayers = Utils.clamp(n, 2, C.MAX_PLAYERS);
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  setHostInput(inp) { this._hostInput = inp; }

  startGame(seed) {
    if (this._gameRunning) return;
    seed = seed || (Date.now() & 0xFFFFFFFF);
    this._gameRunning = true;
    this._round++;

    const players = this._getLobbyData().players;
    const rng = new RNG(seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(players, this._maze);

    // Init scores for new players
    for (const p of players) {
      if (!this._scores.has(p.id)) this._scores.set(p.id, 0);
    }

    // Broadcast start
    const startPkt = Utils.encode(Pkt.make(C.PKT.GAME_START, {round: this._round,
      seed, players, tick: 0,
    }));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(startPkt); } catch {}
    }

    this._onEvent('game_start', {sim: this._sim, maze: this._maze, players, scores: this._getScores(), round: this._round});

    // Timeout checker
    this._pingTimer = setInterval(() => this._checkTimeouts(), 1000);

    // 60 Hz simulation loop
    let lastTime = Utils.now();
    let accumMs = 0;
    let snapTick = 0;

    const loop = () => {
      if (!this._gameRunning) return;
      this._tickLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accumMs += now - lastTime;
      lastTime = now;

      while (accumMs >= C.TICK_MS) {
        accumMs -= C.TICK_MS;
        this._doTick();

        // Send snapshot every SNAP_INTERVAL ticks
        snapTick++;
        if (snapTick >= C.SNAP_INTERVAL) {
          snapTick = 0;
          this._sendSnapshot();
        }

        // Check round end
        if (this._sim.state.roundOver) {
          this._handleRoundEnd();
          return;
        }
      }
    };
    this._tickLoop = requestAnimationFrame(loop);
  }

  _doTick() {
    // Collect all inputs
    const inputs = new Map();
    inputs.set(this._hostId, this._hostInput);
    for (const [id, cl] of this._clients.entries()) {
      inputs.set(id, cl.input || {up:false,down:false,left:false,right:false,fire:false});
    }
    this._sim.tick(inputs);
  }

  _sendSnapshot() {
    const snap = this._sim.serialize();
    const pkt = Utils.encode(Pkt.make(C.PKT.SNAPSHOT, {snap, serverTime: Utils.now()}));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }
  }

  _handleRoundEnd() {
    cancelAnimationFrame(this._tickLoop);
    this._tickLoop = null;
    this._gameRunning = false;

    const wid = this._sim.state.winnerId;
    if (wid) {
      this._scores.set(wid, (this._scores.get(wid)||0) + 1);
    }

    const scores = this._getScores();
    const pkt = Utils.encode(Pkt.make(C.PKT.ROUND_END, {winnerId: wid, scores}));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }

    this._onEvent('round_end', {winnerId: wid, scores});
  }

  _getScores() {
    const arr = [];
    const lobby = this._getLobbyData();
    for (const p of lobby.players) {
      arr.push({id:p.id, name:p.name, color:p.color, wins:this._scores.get(p.id)||0,
        kills: this._sim?.state.tanks.find(t=>t.id===p.id)?.kills || 0});
    }
    return arr;
  }

  _checkTimeouts() {
    const now = Utils.now();
    for (const [id, cl] of this._clients.entries()) {
      if (now - cl.lastSeen > C.TIMEOUT) {
        try { cl.conn.close(); } catch {}
        this._clients.delete(id);
        this._broadcastLobbyState();
        this._onEvent('lobby_changed', this._getLobbyData());
        this._onEvent('player_left', {id});
      }
    }
  }

  destroy() {
    cancelAnimationFrame(this._tickLoop);
    clearInterval(this._pingTimer);
    this._gameRunning = false;
    for (const cl of this._clients.values()) { try { cl.conn.close(); } catch {} }
    try { this._peer.destroy(); } catch {}
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 10 â€” WEBRTC CLIENT
// Connects to host, sends inputs, receives snapshots
// Runs shadow simulation for client-side prediction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class WebRTCClient {
  constructor(onEvent) {
    this._onEvent = onEvent;
    this._peer = null;
    this._conn = null;
    this._playerId = Utils.genId();
    this._playerName = '';
    this._sim = null;      // shadow simulation
    this._maze = null;
    this._ping = -1;
    this._pingTimer = null;
    this._timeoutTimer = null;
    this._lastServerTime = 0;
    this._lastLocalTime = 0;
    this._input = {up:false,down:false,left:false,right:false,fire:false};
    this._lastInputSent = {...this._input};
    this._connected = false;
    this._lobbyPlayers = [];
    this._ready = false;
    this._renderLoop = null;
    this._gameStarted = false;
  }

  get playerId() { return this._playerId; }
  get ping() { return this._ping; }

  async join(name, code) {
    this._playerName = name || 'Player';
    const hostPeerId = 'TS_' + code.toUpperCase();

    return new Promise((resolve, reject) => {
      this._peer = new Peer({
        host: '0.peerjs.com', port: 443, secure: true, path: '/',
        config: {
          iceServers: [
            {urls:'stun:stun.l.google.com:19302'},
            {urls:'stun:stun1.l.google.com:19302'},
          ]
        },
        debug: 0,
      });

      this._peer.on('open', () => {
        this._conn = this._peer.connect(hostPeerId, {reliable: true, serialization: 'none'});
        this._conn.on('open', () => {
          this._connected = true;
          // Send join request
          this._send(Pkt.make(C.PKT.JOIN, {
            playerId: this._playerId, name: this._playerName,
          }));
          // Start ping loop
          this._pingTimer = setInterval(() => this._doPing(), C.PING_INTERVAL);
          this._resetTimeout();
          resolve();
        });
        this._conn.on('data', raw => this._onData(raw));
        this._conn.on('close', () => this._onDisconnect());
        this._conn.on('error', () => this._onDisconnect());

        this._peer.on('error', err => {
          if (!this._connected) reject(err);
          else this._onDisconnect();
        });
      });

      this._peer.on('error', err => reject(err));
    });
  }

  _onData(raw) {
    const pkt = Utils.decode(raw);
    if (!pkt || !Pkt.validate(pkt)) return;
    this._resetTimeout();

    const P = C.PKT;
    switch (pkt.type) {
      case P.LOBBY_STATE:
        this._lobbyPlayers = pkt.players || [];
        this._onEvent('lobby_state', {players: pkt.players, maxPlayers: pkt.maxPlayers, code: pkt.code});
        break;
      case P.GAME_START:
        this._startGame(pkt);
        break;
      case P.SNAPSHOT:
        this._applySnapshot(pkt);
        break;
      case P.ROUND_END:
        this._onEvent('round_end', {winnerId: pkt.winnerId, scores: pkt.scores});
        break;
      case P.KICK:
        this._onEvent('kicked', {reason: pkt.reason});
        this.destroy();
        break;
      case P.PONG:
        this._handlePong(pkt);
        break;
    }
  }

  _startGame(pkt) {
    this._gameStarted = true;
    const rng = new RNG(pkt.seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(pkt.players, this._maze);
    this._onEvent('game_start', {
      sim: this._sim, maze: this._maze,
      players: pkt.players,
      myId: this._playerId,
      round: pkt.round || 1,
    });
    // Start input sending loop
    this._startInputLoop();
  }

  _applySnapshot(pkt) {
    if (!this._sim) return;
    const snap = pkt.snap;
    this._lastServerTime = pkt.serverTime;
    this._lastLocalTime = Utils.now();

    // Reconciliation: apply authoritative snapshot
    this._sim.applySnapshot(snap);

    this._onEvent('snapshot', {snap, ping: this._ping});
  }

  _startInputLoop() {
    // Send inputs at 60 Hz (same as tick rate)
    let tick = 0;
    let last = Utils.now();
    let accum = 0;
    const loop = () => {
      if (!this._gameStarted || !this._connected) return;
      this._renderLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accum += now - last;
      last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        this._sendInput(tick++);
      }
    };
    this._renderLoop = requestAnimationFrame(loop);
  }

  _sendInput(tick) {
    this._send(Pkt.make(C.PKT.INPUT, {
      playerId: this._playerId,
      tick,
      inp: this._input,
    }));
  }

  setInput(inp) { this._input = inp; }

  setReady(isReady) {
    this._ready = isReady;
    this._send(Pkt.make(C.PKT.READY, {playerId: this._playerId, isReady}));
  }

  _doPing() {
    this._send(Pkt.make(C.PKT.PING, {clientTime: Utils.now()}));
  }

  _handlePong(pkt) {
    if (pkt.clientTime) {
      this._ping = Utils.now() - pkt.clientTime;
      this._onEvent('ping', {ping: this._ping});
    }
  }

  _resetTimeout() {
    clearTimeout(this._timeoutTimer);
    this._timeoutTimer = setTimeout(() => this._onDisconnect(), C.TIMEOUT);
  }

  _onDisconnect() {
    if (!this._connected) return;
    this._connected = false;
    this._onEvent('disconnected', {});
    this.destroy();
  }

  _send(obj) {
    if (!this._conn || !this._connected) return;
    try { this._conn.send(Utils.encode(obj)); } catch {}
  }

  destroy() {
    this._gameStarted = false;
    this._connected = false;
    clearInterval(this._pingTimer);
    clearTimeout(this._timeoutTimer);
    cancelAnimationFrame(this._renderLoop);
    try { this._conn?.close(); } catch {}
    try { this._peer?.destroy(); } catch {}
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 11 â€” LOCAL MULTIPLAYER
// Same keyboard, no networking needed
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class LocalGame {
  constructor(onEvent) {
    this._onEvent = onEvent;
    this._sim = null;
    this._maze = null;
    this._players = [];
    this._keyBindings = []; // [{up,down,left,right,fire}] per player
    this._keys = new Set();
    this._tickLoop = null;
    this._round = 1;
    this._scores = new Map();
    this._gameRunning = false;
    this._keyHandler = null;
    this._keyUpHandler = null;
  }

  init(players, keyBindings) {
    this._players = players;
    this._keyBindings = keyBindings;
    this._round = 1;
    this._scores = new Map();
    this.mobileInput = null; // set by App when touch device detected
    players.forEach(p => this._scores.set(p.id, 0));
    this._setupKeys();
  }

  _setupKeys() {
    if (this._keyHandler) {
      window.removeEventListener('keydown', this._keyHandler);
      window.removeEventListener('keyup', this._keyUpHandler);
    }
    this._keyHandler = e => { e.preventDefault(); this._keys.add(e.code); };
    this._keyUpHandler = e => { this._keys.delete(e.code); };
    window.addEventListener('keydown', this._keyHandler, {passive:false});
    window.addEventListener('keyup', this._keyUpHandler, {passive:false});
  }

  startRound() {
    this._gameRunning = true;
    const seed = Date.now() & 0xFFFFFFFF;
    const rng = new RNG(seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(this._players, this._maze);
    this._round++;

    this._onEvent('game_start', {
      sim: this._sim, maze: this._maze,
      players: this._players,
      scores: this._getScores(),
      round: this._round,
    });

    let last = Utils.now(), accum = 0;
    const loop = () => {
      if (!this._gameRunning) return;
      this._tickLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accum += now - last; last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        this._doTick();
        if (this._sim.state.roundOver) {
          this._handleRoundEnd();
          return;
        }
      }
    };
    this._tickLoop = requestAnimationFrame(loop);
  }

  _doTick() {
    const inputs = new Map();
    for (let i=0; i<this._players.length; i++) {
      const kb = this._keyBindings[i];
      const kbInp = {
        up:    this._keys.has(kb.up),
        down:  this._keys.has(kb.down),
        left:  this._keys.has(kb.left),
        right: this._keys.has(kb.right),
        fire:  this._keys.has(kb.fire),
      };
      // For player 0 on touch device, merge mobile input
      if (i === 0 && this.mobileInput) {
        kbInp.up    = kbInp.up    || this.mobileInput.up;
        kbInp.down  = kbInp.down  || this.mobileInput.down;
        kbInp.left  = kbInp.left  || this.mobileInput.left;
        kbInp.right = kbInp.right || this.mobileInput.right;
        kbInp.fire  = kbInp.fire  || this.mobileInput.fire;
      }
      inputs.set(this._players[i].id, kbInp);
    }
    this._sim.tick(inputs);
  }

  _handleRoundEnd() {
    cancelAnimationFrame(this._tickLoop);
    this._gameRunning = false;
    const wid = this._sim.state.winnerId;
    if (wid) this._scores.set(wid, (this._scores.get(wid)||0)+1);
    this._onEvent('round_end', {winnerId: wid, scores: this._getScores()});
  }

  _getScores() {
    return this._players.map((p,i) => ({
      id: p.id, name: p.name,
      color: C.COLORS[i%C.COLORS.length],
      wins: this._scores.get(p.id)||0,
      kills: this._sim?.state.tanks.find(t=>t.id===p.id)?.kills||0,
    }));
  }

  getInput(playerIdx) {
    const kb = this._keyBindings[playerIdx];
    if (!kb) return null;
    return {
      up: this._keys.has(kb.up), down: this._keys.has(kb.down),
      left: this._keys.has(kb.left), right: this._keys.has(kb.right),
      fire: this._keys.has(kb.fire),
    };
  }

  stopRound() {
    cancelAnimationFrame(this._tickLoop);
    this._gameRunning = false;
  }

  destroy() {
    this.stopRound();
    if (this._keyHandler) {
      window.removeEventListener('keydown', this._keyHandler);
      window.removeEventListener('keyup', this._keyUpHandler);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 12 â€” PARTICLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Particles {
  constructor() { this._ps = []; }

  explosion(x, y, color, count=18) {
    for (let i=0; i<count; i++) {
      const a = (Math.PI*2/count)*i + (Math.random()-.5)*.5;
      const spd = 40 + Math.random()*120;
      this._ps.push({
        x, y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd,
        life: 0.4+Math.random()*0.5, maxLife: 0.9,
        r: 2+Math.random()*3, color,
      });
    }
  }

  bulletTrail(x, y, color) {
    this._ps.push({
      x: x+(Math.random()-.5)*3, y: y+(Math.random()-.5)*3,
      vx: (Math.random()-.5)*20, vy: (Math.random()-.5)*20,
      life: 0.06, maxLife: 0.06, r: 1.5, color,
    });
  }

  update(dt) {
    this._ps = this._ps.filter(p => {
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= 0.92; p.vy *= 0.92;
      p.life -= dt;
      return p.life > 0;
    });
  }

  draw(ctx, camX, camY) {
    for (const p of this._ps) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha * 0.85;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x - camX, p.y - camY, p.r * alpha, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 13 â€” RENDERER
// Decoupled from simulation tick, runs at display refresh rate
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Renderer {
  constructor(canvas) {
    this._canvas = canvas;
    this._ctx = canvas.getContext('2d');
    this._particles = new Particles();
    this._prevTanks = null;
    this._renderLoop = null;
    this._fpsFrames = 0;
    this._fpsLast = Utils.now();
    this._fps = 0;
    this._onFps = null;
    this._onPowerup = null;   // callback(label) when player picks up powerup
    this._lastPuLabel = null;
    this._deadEffect = new Map();
    this._flashMap = new Map();
  }

  start(getSim, getMaze, getPlayers, getMyId) {
    this._getSim = getSim;
    this._getMaze = getMaze;
    this._getPlayers = getPlayers;
    this._getMyId = getMyId;

    let last = Utils.now();
    const loop = () => {
      this._renderLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      const dt = Math.min((now - last)/1000, 0.05);
      last = now;
      this._render(dt);
      this._updateFps();
    };
    this._renderLoop = requestAnimationFrame(loop);
  }

  stop() {
    cancelAnimationFrame(this._renderLoop);
    this._renderLoop = null;
  }

  addExplosion(x, y, color) {
    this._particles.explosion(x, y, color);
  }

  flashPlayer(id, color) {
    this._flashMap.set(id, {until: Utils.now()+200, color});
  }

  _render(dt) {
    const sim = this._getSim?.();
    const maze = this._getMaze?.();
    if (!sim || !sim.state || !maze) return;

    const canvas = this._canvas;
    const ctx = this._ctx;

    // Fit canvas to screen â€” account for virtual controls on mobile
    const vc = document.getElementById('vcontrols');
    const vcH = (vc && vc.classList.contains('active'))
      ? parseFloat(getComputedStyle(vc).getPropertyValue('--vc-h')) || 0
      : 0;
    const W = canvas.parentElement?.clientWidth || canvas.clientWidth;
    const H = Math.max(100, (canvas.parentElement?.clientHeight || canvas.clientHeight) - vcH);
    if (canvas.width !== W || canvas.height !== H) {
      canvas.width = W; canvas.height = H;
    }

    // Camera: center maze on canvas
    const mW = maze.W, mH = maze.H;
    const scale = Math.min(W/mW, H/mH) * 0.96;
    const camX = (mW * scale - W) / 2 / scale;
    const camY = (mH * scale - H) / 2 / scale;
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.scale(scale, scale);

    // Background
    ctx.fillStyle = '#0d0d14';
    ctx.fillRect(camX, camY, W/scale, H/scale);

    // Floor (open cells)
    ctx.fillStyle = '#12141f';
    for (const cell of maze.open) {
      ctx.fillRect(cell.x - camX, cell.y - camY, cell.w, cell.h);
    }

    // Grid lines on floor (subtle)
    ctx.strokeStyle = 'rgba(35,38,64,0.4)';
    ctx.lineWidth = 0.5;
    for (const cell of maze.open) {
      ctx.strokeRect(cell.x - camX + 0.5, cell.y - camY + 0.5, cell.w - 1, cell.h - 1);
    }

    // Walls
    for (const w of maze.walls) {
      const wx = w.x - camX, wy = w.y - camY;
      ctx.fillStyle = '#1a1d2e';
      ctx.fillRect(wx, wy, w.w, w.h);
      // Wall highlight (top/left edges)
      ctx.strokeStyle = 'rgba(60,65,100,0.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(wx, wy+w.h); ctx.lineTo(wx, wy); ctx.lineTo(wx+w.w, wy);
      ctx.stroke();
      // Wall shadow (right/bottom)
      ctx.strokeStyle = 'rgba(5,5,10,0.9)';
      ctx.beginPath();
      ctx.moveTo(wx+w.w, wy); ctx.lineTo(wx+w.w, wy+w.h); ctx.lineTo(wx, wy+w.h);
      ctx.stroke();
    }

    // Powerups
    const s = sim.state;
    const now = Utils.now();
    for (const pu of (s.powerups||[])) {
      this._drawPowerup(ctx, pu, now, camX, camY);
    }

    // Bullets
    for (const b of s.bullets) {
      const owner = s.tanks.find(t=>t.id===b.ownerId);
      const col = owner ? owner.color : '#fff';
      const br = b.big ? C.B_RADIUS * 2.5 : C.B_RADIUS;
      this._particles.bulletTrail(b.x, b.y, col);
      ctx.save();
      ctx.shadowColor = col;
      ctx.shadowBlur = b.big ? 18 : 8;
      ctx.fillStyle = b.big ? col : '#fff';
      ctx.beginPath();
      ctx.arc(b.x - camX, b.y - camY, br, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if (!b.big) {
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(b.x - camX, b.y - camY, br * 0.6, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // Tanks
    const myId = this._getMyId?.();
    // Check for powerup pickup for local player feedback
    if (this._onPowerup && myId) {
      const myTank = s.tanks.find(t=>t.id===myId);
      const curPu = myTank?.activePu || null;
      if (curPu !== this._lastPuLabel) {
        this._lastPuLabel = curPu;
        if (curPu) this._onPowerup(curPu);
      }
    }
    for (const t of s.tanks) {
      this._drawTank(ctx, t, t.id === myId, camX, camY);
      if (t.dead) {
        const de = this._deadEffect.get(t.id);
        if (!de) {
          this._deadEffect.set(t.id, Utils.now());
          this._particles.explosion(t.x, t.y, t.color, 24);
        }
      }
    }

    // Particles
    this._particles.update(dt);
    this._particles.draw(ctx, camX, camY);

    ctx.restore();
  }

  _drawPowerup(ctx, pu, now, camX, camY) {
    const puType = POWERUP_TYPES.find(p=>p.id===pu.type);
    if (!puType) return;
    const x = pu.x - camX, y = pu.y - camY;
    const r = C.PU_RADIUS;
    const pulse = 0.85 + 0.15 * Math.sin(now * 0.004);
    const pr = r * pulse;

    ctx.save();
    // Outer glow ring
    ctx.shadowColor = puType.color;
    ctx.shadowBlur = 16;
    ctx.strokeStyle = puType.color;
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(x, y, pr + 3, 0, Math.PI*2);
    ctx.stroke();

    // Inner fill
    ctx.shadowBlur = 0;
    const grad = ctx.createRadialGradient(x, y, 0, x, y, pr);
    grad.addColorStop(0, '#fff');
    grad.addColorStop(0.4, puType.color + 'cc');
    grad.addColorStop(1, puType.color + '44');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, pr, 0, Math.PI*2);
    ctx.fill();

    // Icon text
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${r * 0.75}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(puType.label, x, y);
    ctx.textBaseline = 'alphabetic';

    // Rotating ring segments
    const seg = 6;
    ctx.strokeStyle = puType.color + '88';
    ctx.lineWidth = 1.5;
    for (let i=0;i<seg;i++) {
      const a = (now*0.002) + (i/seg)*Math.PI*2;
      ctx.beginPath();
      ctx.arc(x, y, pr+7, a, a+0.35);
      ctx.stroke();
    }
    ctx.restore();
  }

  _drawTank(ctx, t, isMe, camX, camY) {
    if (t.dead) return;
    const x = t.x - camX, y = t.y - camY;
    const r = C.T_RADIUS, a = t.angle;

    // Ghost tanks are semi-transparent
    const isGhost = t.pu_ghost > 0;

    ctx.save();
    if (isGhost) ctx.globalAlpha = 0.45;
    ctx.translate(x, y);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(2, 4, r*0.9, r*0.6, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.rotate(a);

    // Body glow (for local player)
    if (isMe) {
      ctx.shadowColor = t.color;
      ctx.shadowBlur = 10;
    }

    // Tank body (pentagon-ish via rect + rotated)
    const bodyW = r * 1.7, bodyH = r * 1.4;
    ctx.fillStyle = t.color;
    ctx.fillRect(-bodyW/2, -bodyH/2, bodyW, bodyH);

    // Darker shading
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(-bodyW/2, 0, bodyW, bodyH/2);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(-bodyW/2, -bodyH/2, bodyW, bodyH*0.35);

    // Tracks (left & right)
    const trackW = r*0.35, trackH = r*1.5;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(-bodyW/2 - trackW, -trackH/2, trackW, trackH);
    ctx.fillRect( bodyW/2,          -trackH/2, trackW, trackH);

    // Track links
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    for (let i=-trackH/2; i<trackH/2; i+=5) {
      ctx.beginPath();
      ctx.moveTo(-bodyW/2 - trackW, i);
      ctx.lineTo(-bodyW/2, i);
      ctx.moveTo(bodyW/2, i);
      ctx.lineTo(bodyW/2 + trackW, i);
      ctx.stroke();
    }

    // Turret base
    ctx.shadowBlur = 0;
    ctx.fillStyle = this._lerpColor(t.color, '#ffffff', 0.15);
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.52, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Barrel
    ctx.fillStyle = this._lerpColor(t.color, '#000000', 0.2);
    ctx.fillRect(0, -r*0.18, C.T_BARREL, r*0.36);
    // Barrel highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(0, -r*0.18, C.T_BARREL, r*0.1);

    // Name label
    ctx.rotate(-a);
    ctx.font = `bold ${r*0.7}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillText(t.name?.slice(0,8)||'', 1, -r*1.6+1);
    ctx.fillStyle = isMe ? '#fff' : t.color;
    ctx.fillText(t.name?.slice(0,8)||'', 0, -r*1.6);

    // Active powerup badge
    if (t.activePu) {
      const puType = POWERUP_TYPES.find(p=>p.label===t.activePu);
      const badgeCol = puType ? puType.color : '#fff';
      ctx.font = `bold ${r*0.62}px monospace`;
      const bw = ctx.measureText(t.activePu).width + 6;
      ctx.fillStyle = badgeCol + 'cc';
      ctx.fillRect(-bw/2, -r*2.5 - r*0.5, bw, r*0.72);
      ctx.fillStyle = '#fff';
      ctx.fillText(t.activePu, 0, -r*2.5);
    }

    // Shield visual ring (drawn before ctx.restore so it's in local coords)
    if (t.pu_shield > 0) {
      ctx.strokeStyle = '#42c87a';
      ctx.lineWidth = 2.5;
      ctx.shadowColor = '#42c87a';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(0, 0, r * 1.4, 0, Math.PI*2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    ctx.restore();

  }

  _lerpColor(hex1, hex2, t) {
    const p = s => parseInt(s,16);
    const r1=p(hex1.slice(1,3)),g1=p(hex1.slice(3,5)),b1=p(hex1.slice(5,7));
    const r2=p(hex2.slice(1,3)),g2=p(hex2.slice(3,5)),b2=p(hex2.slice(5,7));
    const ri=Math.round(r1+(r2-r1)*t);
    const gi=Math.round(g1+(g2-g1)*t);
    const bi=Math.round(b1+(b2-b1)*t);
    return `rgb(${ri},${gi},${bi})`;
  }

  _updateFps() {
    this._fpsFrames++;
    const now = Utils.now();
    if (now - this._fpsLast >= 500) {
      this._fps = Math.round(this._fpsFrames * 1000 / (now - this._fpsLast));
      this._fpsFrames = 0;
      this._fpsLast = now;
      this._onFps?.(this._fps);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 14 â€” ANIMATED MENU BACKGROUND
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startMenuBG() {
  const canvas = document.getElementById('bg-canvas');
  const ctx = canvas.getContext('2d');
  const tanks = [];
  const bullets_bg = [];

  function resize() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
  resize();
  window.addEventListener('resize', resize);

  for (let i=0;i<5;i++) {
    tanks.push({
      x: Math.random()*canvas.width, y: Math.random()*canvas.height,
      angle: Math.random()*Math.PI*2, color: C.COLORS[i%C.COLORS.length],
      vx:0,vy:0, fireCd:0,
    });
  }

  let last = Utils.now();
  function loop() {
    requestAnimationFrame(loop);
    const now = Utils.now();
    const dt = Math.min((now-last)/1000,0.05); last=now;
    const W=canvas.width, H=canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#09090f';
    ctx.fillRect(0,0,W,H);

    for (const t of tanks) {
      t.angle += 0.4*dt*(Math.sin(now*0.0003+t.x)*0.5+0.5)*2-0.2;
      t.x += Math.cos(t.angle)*40*dt;
      t.y += Math.sin(t.angle)*40*dt;
      if(t.x<0)t.x=W; if(t.x>W)t.x=0;
      if(t.y<0)t.y=H; if(t.y>H)t.y=0;
      t.fireCd -= dt;
      if(t.fireCd<=0) {
        t.fireCd = 1.5+Math.random()*2;
        bullets_bg.push({
          x:t.x+Math.cos(t.angle)*20, y:t.y+Math.sin(t.angle)*20,
          vx:Math.cos(t.angle)*180, vy:Math.sin(t.angle)*180,
          color:t.color, life:3,
        });
      }
      // Draw tank
      ctx.save();
      ctx.translate(t.x,t.y);
      ctx.globalAlpha=0.25;
      ctx.fillStyle=t.color;
      ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
      ctx.rotate(t.angle);
      ctx.fillRect(0,-4,20,8);
      ctx.restore();
    }

    for (let i=bullets_bg.length-1;i>=0;i--) {
      const b=bullets_bg[i];
      b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt;
      if(b.x<0||b.x>W||b.y<0||b.y>H||b.life<=0){bullets_bg.splice(i,1);continue;}
      ctx.globalAlpha=b.life/3*0.3;
      ctx.fillStyle=b.color;
      ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;
  }
  loop();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 15 â€” KEY BINDINGS UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class KeyBindingsUI {
  constructor(containerId) {
    this._container = document.getElementById(containerId);
    this._bindings = C.DEFAULT_KEYS.map(kb => ({
      up:kb[0],down:kb[1],left:kb[2],right:kb[3],fire:kb[4]
    }));
    this._playerCount = 2;
    this._listening = null; // {playerIdx, action, btn}
    this._keyHandler = null;
  }

  setPlayerCount(n) {
    this._playerCount = Utils.clamp(n, 2, C.MAX_PLAYERS);
    // Extend bindings if needed
    while (this._bindings.length < this._playerCount) {
      this._bindings.push({up:'',down:'',left:'',right:'',fire:''});
    }
    this._render();
  }

  getBindings() { return this._bindings.slice(0, this._playerCount); }

  _render() {
    this._container.innerHTML = '';
    if (this._keyHandler) window.removeEventListener('keydown', this._keyHandler);

    for (let i=0; i<this._playerCount; i++) {
      const b = this._bindings[i];
      const col = C.COLORS[i%C.COLORS.length];
      const div = document.createElement('div');
      div.className = 'binding-group';
      div.innerHTML = `
        <div class="binding-title" style="color:${col}">Player ${i+1}</div>
        <div class="binding-grid">
          ${['up','down','left','right','fire'].map(action => `
            <span class="binding-lbl">${action.toUpperCase()}</span>
            <button class="key-btn" data-player="${i}" data-action="${action}">${Utils.keyName(b[action]||'?')}</button>
          `).join('')}
        </div>`;
      this._container.appendChild(div);
    }

    // Event delegation
    this._container.querySelectorAll('.key-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (this._listening) {
          this._listening.btn.classList.remove('listening');
          this._listening.btn.textContent = Utils.keyName(this._bindings[this._listening.pi][this._listening.action]||'?');
        }
        const pi = +btn.dataset.player, action = btn.dataset.action;
        this._listening = {pi, action, btn};
        btn.classList.add('listening');
        btn.textContent = '...';
        this._startListening();
      });
    });
  }

  _startListening() {
    if (this._keyHandler) window.removeEventListener('keydown', this._keyHandler);
    this._keyHandler = e => {
      e.preventDefault();
      if (!this._listening) return;
      const {pi, action, btn} = this._listening;
      this._bindings[pi][action] = e.code;
      btn.classList.remove('listening');
      btn.textContent = Utils.keyName(e.code);
      this._listening = null;
      window.removeEventListener('keydown', this._keyHandler);
    };
    window.addEventListener('keydown', this._keyHandler);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 16 â€” SCREEN MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const Screens = {
  _active: 'menu',
  go(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById('screen-'+id);
    if (el) { el.classList.add('active'); this._active = id; }
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 17 â€” APP (Main controller)
// Wires everything together
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const App = (() => {
  // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let mode = null; // 'local' | 'host' | 'client'
  let host = null, client = null, localGame = null;
  let sim = null, maze = null;
  let players = [];
  let myId = null;
  let scores = [];
  let round = 1;
  let ping = -1;
  let keyBindingsUI = null;
  let renderer = null;
  let gameCanvas = null;
  let isHost = false;
  let isReady = false;
  let localPlayerCount = 2;

  // Online: single-player key input
  let onlineKeys = new Set();
  let onlineKeyHandler = null, onlineKeyUpHandler = null;
  const onlineBinding = {up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',fire:'Space'};

  // â”€â”€ DOM refs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const $ = id => document.getElementById(id);

  function init() {
    gameCanvas = $('game-canvas');
    renderer = new Renderer(gameCanvas);
    renderer._onFps = fps => { $('hud-fps').textContent = `FPS: ${fps}`; };

    keyBindingsUI = new KeyBindingsUI('bindings-wrap');
    keyBindingsUI.setPlayerCount(2);

    // Prevent F5/context menu during game
    window.addEventListener('keydown', e => {
      if (e.code === 'F5') e.preventDefault();
      // ESC to leave game (with confirm)
      if (e.code === 'Escape' && Screens._active === 'game') {
        if (confirm('Leave current game?')) leaveGame();
      }
    });
    window.addEventListener('contextmenu', e => {
      if (Screens._active === 'game') e.preventDefault();
    });

    bindMenuEvents();
    bindLobbyEvents();
    bindGameEvents();
    bindScoreEvents();
    startMenuBG();

    // Mobile: leave button inside game screen
    const lb = document.getElementById('vleave-btn');
    if (lb) {
      lb.addEventListener('click', () => {
        if (confirm('Leave game?')) leaveGame();
      });
      lb.addEventListener('touchend', e => {
        e.preventDefault();
        if (confirm('Leave game?')) leaveGame();
      });
    }

    // Mobile: disable pull-to-refresh and double-tap zoom globally
    document.addEventListener('touchmove', e => {
      if (Screens._active === 'game') e.preventDefault();
    }, {passive: false});
    document.addEventListener('gesturestart', e => e.preventDefault(), {passive:false});
    document.addEventListener('dblclick', e => e.preventDefault());
  }

  // â”€â”€ Menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function bindMenuEvents() {
    // On touch devices adapt the local multiplayer button label
    if (MobileControls.isTouch()) {
      const bl = $('btn-local');
      if (bl) bl.textContent = 'SOLO / LOCAL (1 JOYSTICK)';
    }

    $('btn-local').onclick = () => Screens.go('local');
    $('btn-online').onclick = () => Screens.go('online');
    $('btn-howto').onclick = () => Screens.go('howto');
    $('btn-howto-back').onclick = () => Screens.go('menu');
    $('btn-local-back').onclick = () => Screens.go('menu');
    $('btn-online-back').onclick = () => Screens.go('menu');

    // Local player count
    $('local-dec').onclick = () => {
      localPlayerCount = Math.max(2, localPlayerCount - 1);
      $('local-count').textContent = localPlayerCount;
      keyBindingsUI.setPlayerCount(localPlayerCount);
    };
    $('local-inc').onclick = () => {
      localPlayerCount = Math.min(C.MAX_PLAYERS, localPlayerCount + 1);
      $('local-count').textContent = localPlayerCount;
      keyBindingsUI.setPlayerCount(localPlayerCount);
    };

    $('btn-local-start').onclick = startLocalGame;

    // Online
    $('btn-host').onclick = hostGame;
    $('btn-join').onclick = joinGame;
  }

  function startLocalGame() {
    mode = 'local';
    const bindings = keyBindingsUI.getBindings();
    players = bindings.map((_,i) => ({
      id: Utils.genId(), name: `Player ${i+1}`,
      color: C.COLORS[i%C.COLORS.length],
    }));
    localGame = new LocalGame(handleLocalEvent);
    localGame.init(players, bindings.map(b=>({...b})));

    // On touch devices, enable mobile controls for player 1
    if (MobileControls.isTouch()) {
      MobileControls.enable((inp) => {
        if (localGame) localGame.mobileInput = inp;
      });
    }

    localGame.startRound();
  }

  function handleLocalEvent(type, data) {
    switch(type) {
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; myId = null;
        scores = data.scores || [];
        round = data.round || 1;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer._lastPuLabel = null;
        renderer._onPowerup = (label) => {
          const t = sim?.state?.tanks?.find(t=>t.id===myId);
          const puType = t ? POWERUP_TYPES.find(p=>p.label===label) : null;
          showPuToast(label, puType?.color||'#fff');
        };
        renderer.start(
          () => sim, () => maze, () => players, () => myId
        );
        break;
      case 'round_end':
        scores = data.scores || [];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, true);
        }, 2200);
        showOverlay(data.winnerId);
        break;
    }
  }

  // â”€â”€ Online Host â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showConnecting(msg) {
    const el = document.getElementById('connecting-overlay');
    document.getElementById('connecting-msg').textContent = msg;
    el.style.display = 'flex';
    let w = 0;
    const bar = document.getElementById('conn-bar');
    const iv = setInterval(() => { w = Math.min(w+3, 90); bar.style.width=w+'%'; }, 100);
    return () => { clearInterval(iv); bar.style.width='100%'; setTimeout(()=>el.style.display='none',400); };
  }

  async function hostGame() {
    const name = $('host-name').value.trim() || 'Host';
    const hideConnecting = showConnecting('CREATING LOBBY...');
    setOnlineStatus('Connecting to signaling serverâ€¦', 'info');

    mode = 'host';
    isHost = true;
    myId = null; // will be set after lobby created

    host = new WebRTCHost(handleHostEvent);
    try {
      const code = await host.createLobby(name);
      myId = host.hostId;
      $('lobby-code-val').textContent = code;
      $('lobby-max-val').textContent = '8';
      $('lobby-host-settings').style.display = 'flex';
      $('btn-lobby-start').classList.remove('hidden');
      $('btn-ready').classList.add('hidden');
      isReady = true;
      updateLobbyUI(host._getLobbyData());
      hideConnecting();
      hideConnecting();
      Screens.go('lobby');
      setOnlineStatus('', '');
      setupOnlineKeys();
    } catch(err) {
      console.error(err);
      hideConnecting();
      setOnlineStatus('Failed to create lobby: ' + (err.message||err.type||err), 'err');
      host?.destroy(); host = null;
    }
  }

  function handleHostEvent(type, data) {
    switch(type) {
      case 'lobby_created':
        myId = data.hostId;
        break;
      case 'lobby_changed':
        updateLobbyUI(data);
        break;
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; scores = data.scores||[];
        round = data.round||1;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer._lastPuLabel = null;
        renderer._onPowerup = (label) => {
          const t = sim?.state?.tanks?.find(t=>t.id===myId);
          const puType = t ? POWERUP_TYPES.find(p=>p.label===label) : null;
          showPuToast(label, puType?.color||'#fff');
        };
        renderer.start(() => sim, () => maze, () => players, () => myId);
        break;
      case 'round_end':
        scores = data.scores||[];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, true);
        }, 2200);
        showOverlay(data.winnerId);
        break;
      case 'player_left':
        break;
    }
  }

  // â”€â”€ Online Client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  async function joinGame() {
    const name = $('join-name').value.trim() || 'Player';
    const code = $('join-code').value.trim().toUpperCase();
    if (code.length !== 6) { setOnlineStatus('Enter a valid 6-char join code', 'err'); return; }

    const hideConnecting = showConnecting('JOINING LOBBY...');
    setOnlineStatus('Connectingâ€¦', 'info');
    mode = 'client';
    isHost = false;

    client = new WebRTCClient(handleClientEvent);
    try {
      await client.join(name, code);
      myId = client.playerId;
      $('lobby-code-val').textContent = code;
      $('lobby-host-settings').style.display = 'none';
      $('btn-lobby-start').classList.add('hidden');
      $('btn-ready').classList.remove('hidden');
      isReady = false;
      $('btn-ready').dataset.ready = 'false';
      $('btn-ready').textContent = 'Ready';
      hideConnecting();
      hideConnecting();
      Screens.go('lobby');
      setOnlineStatus('', '');
      setupOnlineKeys();
    } catch(err) {
      console.error(err);
      hideConnecting();
      setOnlineStatus('Failed to connect: ' + (err.message||err.type||err), 'err');
      client?.destroy(); client = null;
    }
  }

  function handleClientEvent(type, data) {
    switch(type) {
      case 'lobby_state':
        updateLobbyUI({players: data.players, maxPlayers: data.maxPlayers, code: data.code});
        break;
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; myId = data.myId;
        if (data.round) round = data.round;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer._lastPuLabel = null;
        renderer._onPowerup = (label) => {
          const t = sim?.state?.tanks?.find(t=>t.id===myId);
          const puType = t ? POWERUP_TYPES.find(p=>p.label===label) : null;
          showPuToast(label, puType?.color||'#fff');
        };
        renderer.start(() => sim, () => maze, () => players, () => myId);
        break;
      case 'snapshot':
        ping = data.ping;
        $('hud-ping').textContent = ping >= 0 ? `PING: ${Math.round(ping)}ms` : 'PING: â€”';
        updateHudScores();
        checkMyPowerup(data.snap);
        break;
      case 'round_end':
        scores = data.scores||[];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, false);
        }, 2200);
        showOverlay(data.winnerId);
        break;
      case 'ping':
        ping = data.ping;
        $('hud-ping').textContent = `PING: ${Math.round(ping)}ms`;
        // Update lobby ping display
        $('lobby-ping-row').textContent = `Your ping: ${Math.round(ping)}ms`;
        break;
      case 'kicked':
        alert('Kicked: ' + (data.reason||'unknown reason'));
        leaveGame();
        break;
      case 'disconnected':
        alert('Disconnected from host.');
        leaveGame();
        break;
    }
  }

  // â”€â”€ Online Key + Mobile Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // mobileInput holds the latest touch-derived input state
  let mobileInput = {up:false,down:false,left:false,right:false,fire:false};
  let mobileEnabled = false;

  function setupOnlineKeys() {
    removeOnlineKeys();
    onlineKeys = new Set();
    onlineKeyHandler = e => { e.preventDefault(); onlineKeys.add(e.code); };
    onlineKeyUpHandler = e => { onlineKeys.delete(e.code); };
    window.addEventListener('keydown', onlineKeyHandler, {passive:false});
    window.addEventListener('keyup', onlineKeyUpHandler);

    // Enable mobile controls if touch device
    if (MobileControls.isTouch()) {
      mobileEnabled = true;
      MobileControls.enable((inp) => { mobileInput = inp; });
    }

    // Input pump at 60Hz â€” merges keyboard + touch
    let last = Utils.now(), accum = 0;
    function inputLoop() {
      if (!onlineKeyHandler && !mobileEnabled) return;
      requestAnimationFrame(inputLoop);
      const now = Utils.now();
      accum += now - last; last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        const inp = {
          up:    onlineKeys.has(onlineBinding.up)    || mobileInput.up,
          down:  onlineKeys.has(onlineBinding.down)  || mobileInput.down,
          left:  onlineKeys.has(onlineBinding.left)  || mobileInput.left,
          right: onlineKeys.has(onlineBinding.right) || mobileInput.right,
          fire:  onlineKeys.has(onlineBinding.fire)  || mobileInput.fire,
        };
        if (host) host.setHostInput(inp);
        if (client) client.setInput(inp);
      }
    }
    requestAnimationFrame(inputLoop);
  }

  function removeOnlineKeys() {
    if (onlineKeyHandler) window.removeEventListener('keydown', onlineKeyHandler);
    if (onlineKeyUpHandler) window.removeEventListener('keyup', onlineKeyUpHandler);
    onlineKeyHandler = null; onlineKeyUpHandler = null;
    if (mobileEnabled) { MobileControls.disable(); mobileEnabled = false; }
    mobileInput = {up:false,down:false,left:false,right:false,fire:false};
  }

  // â”€â”€ Lobby UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function bindLobbyEvents() {
    $('btn-copy-code').onclick = () => {
      const code = $('lobby-code-val').textContent;
      navigator.clipboard?.writeText(code).catch(()=>{});
      $('btn-copy-code').textContent = 'Copied!';
      setTimeout(() => $('btn-copy-code').textContent = 'Copy', 1500);
    };

    $('lobby-max-dec').onclick = () => {
      if (!host) return;
      host.setMaxPlayers(host._maxPlayers - 1);
      $('lobby-max-val').textContent = host._maxPlayers;
    };
    $('lobby-max-inc').onclick = () => {
      if (!host) return;
      host.setMaxPlayers(host._maxPlayers + 1);
      $('lobby-max-val').textContent = host._maxPlayers;
    };

    $('btn-ready').onclick = () => {
      if (!client) return;
      isReady = !isReady;
      $('btn-ready').dataset.ready = isReady ? 'true' : 'false';
      $('btn-ready').textContent = isReady ? 'âœ“ Ready' : 'Ready';
      $('btn-ready').className = isReady ? 'btn btn-grn btn-sm on' : 'btn btn-grn btn-sm';
      client.setReady(isReady);
    };

    $('btn-lobby-start').onclick = () => {
      if (!host) return;
      host.startGame();
    };

    $('btn-lobby-leave').onclick = leaveGame;
  }

  function updateLobbyUI(data) {
    if (!data) return;
    const {players: pls, maxPlayers: mp, code} = data;
    if (code) $('lobby-code-val').textContent = code;
    $('lobby-pl-count').textContent = `${pls.length}/${mp||8}`;

    const list = $('lobby-pl-list');
    list.innerHTML = '';
    pls.forEach((p,i) => {
      const row = document.createElement('div');
      row.className = 'pl-row';
      const ping = p.ping >= 0 ? `${Math.round(p.ping)}ms` : (p.isHost ? 'host' : 'â€”');
      row.innerHTML = `
        <div class="pl-dot" style="background:${p.color||C.COLORS[i%C.COLORS.length]}"></div>
        <span class="pl-name">${escHtml(p.name)}</span>
        <span class="pl-ping">${ping}</span>
        ${p.isHost ? '<span class="pl-host">HOST</span>' : `<span class="pl-ready ${p.ready?'y':'n'}">${p.ready?'READY':'NOT READY'}</span>`}
      `;
      list.appendChild(row);
    });
    $('lobby-max-val').textContent = mp || 8;
  }

  // â”€â”€ Game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let _lastPu = null;
  function checkMyPowerup(snap) {
    if (!snap || !myId) return;
    const t = snap.tanks?.find(tt=>tt.id===myId);
    if (!t) return;
    if (t.activePu !== _lastPu) {
      _lastPu = t.activePu;
      if (t.activePu) {
        const puType = POWERUP_TYPES.find(p=>p.label===t.activePu);
        showPuToast(t.activePu, puType?.color||'#fff');
      }
    }
  }

  function showPuToast(label, color) {
    const el = document.getElementById('pu-toast');
    if (!el) return;
    el.textContent = '+ ' + label;
    el.style.color = color;
    el.style.borderColor = color;
    el.style.background = color + '22';
    el.classList.add('show');
    clearTimeout(el._timer);
    el._timer = setTimeout(() => el.classList.remove('show'), 2200);
  }

  function updateHudScores() {
    const hud = $('hud-scores');
    if (!players.length) return;
    hud.innerHTML = '';
    players.forEach(p => {
      const sc = scores.find(s=>s.id===p.id);
      const wins = sc?.wins ?? 0;
      const div = document.createElement('div');
      div.className = 'hud-score';
      div.innerHTML = `<div class="hud-dot" style="background:${p.color}"></div>
        <span style="color:${p.color}">${escHtml(p.name.slice(0,8))}</span>
        <span style="color:#e8c870;font-weight:bold">${wins}</span>`;
      hud.appendChild(div);
    });
  }

  function showOverlay(winnerId) {
    const ov = $('game-overlay');
    ov.classList.remove('hidden');
    const winner = players.find(p=>p.id===winnerId);
    $('ov-title').textContent = winner ? `${winner.name} Wins!` : 'Draw!';
    $('ov-title').style.color = winner ? winner.color : 'var(--gold)';
    $('ov-sub').textContent = 'Showing scoreboardâ€¦';

    if (sim) {
      const tank = sim.state.tanks.find(t=>t.id===winnerId);
      if (tank) renderer.addExplosion(tank.x, tank.y, tank.color);
    }
  }

  function hideOverlay() { $('game-overlay').classList.add('hidden'); }

  function bindGameEvents() {
    // Game overlay auto-dismisses via setTimeout in event handlers
  }

  // â”€â”€ Scoreboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function showScoreboard(winnerId, scoreData, canStartNext) {
    Screens.go('scoreboard');
    hideOverlay();
    const list = $('score-list');
    list.innerHTML = '';
    const sorted = [...(scoreData||[])].sort((a,b)=>b.wins-a.wins);
    sorted.forEach((s,i) => {
      const row = document.createElement('div');
      row.className = 'score-row';
      row.innerHTML = `
        <div class="score-rank ${i===0?'r1':''}">${i===1?'2':i===2?'3':i===0?'1':i+1}</div>
        <div class="score-bar" style="background:${s.color}"></div>
        <div class="score-name" style="color:${s.color}">${escHtml(s.name)}</div>
        <div class="score-kills">${s.kills} kill${s.kills===1?'':'s'}</div>
        <div class="score-wins">${s.wins}<div style="font-family:var(--mono);font-size:9px;color:var(--textd);letter-spacing:.15em">WIN${s.wins===1?'':'S'}</div></div>
      `;
      list.appendChild(row);
    });

    $('btn-score-next').style.display = canStartNext ? '' : 'none';
    $('btn-score-next').textContent = mode==='client' ? 'Wait for hostâ€¦' : 'Next Round';
    $('btn-score-next').disabled = mode==='client';
  }

  function bindScoreEvents() {
    $('btn-score-menu').onclick = () => {
      leaveGame();
      Screens.go('menu');
    };
    $('btn-score-next').onclick = () => {
      if (mode === 'local') {
        localGame.startRound();
      } else if (mode === 'host' && host) {
        host.startGame();
      }
    };
  }

  // â”€â”€ Leave â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function leaveGame() {
    renderer.stop();
    removeOnlineKeys();
    // Disable mobile controls if local game used them directly
    if (mode === 'local') MobileControls.disable();
    if (localGame) { localGame.destroy(); localGame = null; }
    if (host) { host.destroy(); host = null; }
    if (client) { client.destroy(); client = null; }
    sim = null; maze = null; players = []; myId = null;
    scores = []; isReady = false; mode = null; isHost = false;
    $('game-overlay').classList.add('hidden');
    Screens.go('menu');
  }

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function setOnlineStatus(msg, cls) {
    const el = $('online-status');
    el.textContent = msg;
    el.className = 'status ' + (cls||'');
  }

  function setLobbyStatus(msg, cls) {
    const el = $('lobby-status');
    el.textContent = msg;
    el.className = 'status ' + (cls||'');
  }

  function escHtml(s) {
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  return { init };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SECTION 18 â€” MOBILE CONTROLS
// Virtual joystick (left thumb) + fire button (right thumb).
// Produces the same {up,down,left,right,fire} input struct as
// the keyboard path, so zero simulation changes needed.
//
// Joystick: dynamic origin (appears where thumb touches).
// Deadzone: 12px.  Full deflection zone: 48px radius.
// Rotation maps to left/right; forward/back maps to up/down.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MobileControls = (() => {
  const DEAD = 12;        // deadzone px
  const MAX_R = 50;       // full-deflection radius px
  const JOY_VISUAL_R = 55; // visual base radius px

  let active = false;
  let onInput = null; // callback(inp)

  // Joystick state
  let joyTouchId = null;
  let joyOriginX = 0, joyOriginY = 0;
  let joyDx = 0, joyDy = 0;

  // Fire state
  let fireTouchId = null;
  let fireActive = false;

  // DOM refs
  const vcEl    = () => document.getElementById('vcontrols');
  const joyZone = () => document.getElementById('vjoy-zone');
  const joyBase = () => document.getElementById('vjoy-base');
  const joyStick= () => document.getElementById('vjoy-stick');
  const fireBtn = () => document.getElementById('vfire-btn');
  const rotOv   = () => document.getElementById('rotate-overlay');
  const leaveBtn= () => document.getElementById('vleave-btn');

  function isTouchDevice() {
    return navigator.maxTouchPoints > 0 || 'ontouchstart' in window;
  }

  function isLandscape() {
    return window.innerWidth > window.innerHeight;
  }

  // Show/hide the rotate overlay based on orientation
  function checkOrientation() {
    if (!active) return;
    const ro = rotOv();
    if (!ro) return;
    if (!isLandscape()) {
      ro.classList.add('show');
    } else {
      ro.classList.remove('show');
    }
  }

  // Position base visually at origin
  function placeBase(x, y) {
    const zone = joyZone();
    if (!zone) return;
    const rect = zone.getBoundingClientRect();
    const bx = x - rect.left;
    const by = y - rect.top;
    const base = joyBase();
    const stick = joyStick();
    if (base) { base.style.left = bx+'px'; base.style.top = by+'px'; }
    if (stick) { stick.style.left = bx+'px'; stick.style.top = by+'px'; }
  }

  // Update stick visual position
  function placeStick(ox, oy, cx, cy) {
    const zone = joyZone();
    if (!zone) return;
    const rect = zone.getBoundingClientRect();
    let dx = cx - ox, dy = cy - oy;
    const dist = Math.hypot(dx, dy);
    if (dist > JOY_VISUAL_R) {
      dx = (dx/dist)*JOY_VISUAL_R;
      dy = (dy/dist)*JOY_VISUAL_R;
    }
    const stick = joyStick();
    if (stick) {
      stick.style.left = (ox - rect.left + dx)+'px';
      stick.style.top  = (oy - rect.top  + dy)+'px';
    }
  }

  // Convert joystick dx/dy to input struct
  function computeInput() {
    const dist = Math.hypot(joyDx, joyDy);
    const inp = {up:false,down:false,left:false,right:false,fire:fireActive};
    if (dist < DEAD) return inp;

    // Angle: right=0, down=PI/2
    const angle = Math.atan2(joyDy, joyDx);

    // Forward = joystick up (negative dy), Back = joystick down (positive dy)
    // Threshold: within 120Â° arc of pure up/down for movement
    const absAngle = Math.abs(angle);
    const absDy = Math.abs(joyDy), absDx = Math.abs(joyDx);

    // Use analog: if mostly vertical â†’ move, if mostly horizontal â†’ rotate, diagonal â†’ both
    const norm = dist > 0 ? dist : 1;
    const fx = joyDx / norm; // -1..1
    const fy = joyDy / norm;

    // Deadzone for each axis separately
    if (fy < -0.3) inp.up = true;    // stick up   â†’ move forward
    if (fy >  0.3) inp.down = true;  // stick down â†’ move backward
    if (fx < -0.35) inp.left = true;  // stick left  â†’ rotate left
    if (fx >  0.35) inp.right = true; // stick right â†’ rotate right

    return inp;
  }

  // Touch handlers for joystick zone
  function onJoyStart(e) {
    e.preventDefault();
    const touches = e.changedTouches;
    for (const t of touches) {
      if (joyTouchId !== null) continue; // already tracking one
      const zone = joyZone();
      if (!zone) continue;
      const rect = zone.getBoundingClientRect();
      if (t.clientX < rect.right) {
        joyTouchId = t.identifier;
        joyOriginX = t.clientX;
        joyOriginY = t.clientY;
        joyDx = 0; joyDy = 0;
        placeBase(t.clientX, t.clientY);
        placeStick(t.clientX, t.clientY, t.clientX, t.clientY);
        // Show base
        const base = joyBase();
        if (base) base.style.opacity = '1';
      }
    }
  }

  function onJoyMove(e) {
    e.preventDefault();
    const touches = e.changedTouches;
    for (const t of touches) {
      if (t.identifier !== joyTouchId) continue;
      joyDx = t.clientX - joyOriginX;
      joyDy = t.clientY - joyOriginY;
      const dist = Math.hypot(joyDx, joyDy);
      if (dist > MAX_R) {
        joyDx = (joyDx/dist)*MAX_R;
        joyDy = (joyDy/dist)*MAX_R;
      }
      placeStick(joyOriginX, joyOriginY, t.clientX, t.clientY);
      if (onInput) onInput(computeInput());
    }
  }

  function onJoyEnd(e) {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier !== joyTouchId) continue;
      joyTouchId = null;
      joyDx = 0; joyDy = 0;
      // Hide base & center stick
      const base = joyBase(), stick = joyStick();
      if (base) base.style.opacity = '0';
      if (stick && base) {
        stick.style.left = base.style.left;
        stick.style.top  = base.style.top;
      }
      if (onInput) onInput(computeInput());
    }
  }

  // Fire button handlers â€” supports hold-to-autofire
  let fireInterval = null;
  function onFireStart(e) {
    e.preventDefault();
    if (fireTouchId !== null) return;
    fireTouchId = e.changedTouches[0].identifier;
    fireActive = true;
    const btn = fireBtn();
    if (btn) btn.classList.add('pressed');
    if (onInput) onInput(computeInput());
    // Auto-repeat fire every 100ms while held
    fireInterval = setInterval(() => {
      if (onInput) onInput(computeInput());
    }, 100);
  }

  function onFireEnd(e) {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier !== fireTouchId) continue;
      fireTouchId = null;
      fireActive = false;
      clearInterval(fireInterval);
      const btn = fireBtn();
      if (btn) btn.classList.remove('pressed');
      if (onInput) onInput(computeInput());
    }
  }

  function show() {
    const vc = vcEl();
    if (vc) {
      // Set height based on screen
      const h = Math.min(220, window.innerHeight * 0.32);
      vc.style.setProperty('--vc-h', h+'px');
      vc.classList.add('active');
    }
    checkOrientation();
  }

  function hide() {
    const vc = vcEl();
    if (vc) vc.classList.remove('active');
    const ro = rotOv();
    if (ro) ro.classList.remove('show');
  }

  function enable(inputCallback) {
    if (!isTouchDevice()) return false;
    active = true;
    onInput = inputCallback;

    const zone = joyZone();
    if (zone) {
      zone.addEventListener('touchstart', onJoyStart, {passive:false});
      zone.addEventListener('touchmove',  onJoyMove,  {passive:false});
      zone.addEventListener('touchend',   onJoyEnd,   {passive:false});
      zone.addEventListener('touchcancel',onJoyEnd,   {passive:false});
      // Hide base initially
      const base = joyBase();
      if (base) base.style.opacity = '0';
    }

    const fb = fireBtn();
    if (fb) {
      fb.addEventListener('touchstart', onFireStart, {passive:false});
      fb.addEventListener('touchend',   onFireEnd,   {passive:false});
      fb.addEventListener('touchcancel',onFireEnd,   {passive:false});
    }

    window.addEventListener('orientationchange', checkOrientation);
    window.addEventListener('resize', checkOrientation);
    show();
    return true;
  }

  function disable() {
    active = false;
    onInput = null;
    joyTouchId = null; fireTouchId = null;
    joyDx = 0; joyDy = 0; fireActive = false;
    clearInterval(fireInterval);

    const zone = joyZone();
    if (zone) {
      zone.removeEventListener('touchstart', onJoyStart);
      zone.removeEventListener('touchmove',  onJoyMove);
      zone.removeEventListener('touchend',   onJoyEnd);
      zone.removeEventListener('touchcancel',onJoyEnd);
    }
    const fb = fireBtn();
    if (fb) {
      fb.removeEventListener('touchstart', onFireStart);
      fb.removeEventListener('touchend',   onFireEnd);
      fb.removeEventListener('touchcancel',onFireEnd);
    }
    window.removeEventListener('orientationchange', checkOrientation);
    window.removeEventListener('resize', checkOrientation);
    hide();
  }

  function isTouch() { return isTouchDevice(); }

  return { enable, disable, isTouch };
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('DOMContentLoaded', () => App.init());
</script>
</body>
</html>
