<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TANK SIEGE</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
/* ═══════════════════════════════════════════════════════════
   TANK SIEGE — Styles
   Theme: Military Industrial / CRT Terminal
═══════════════════════════════════════════════════════════ */
:root {
  --bg:#09090f;--bg2:#0f101a;--panel:#12141f;--panel2:#181b2a;
  --border:#252840;--border2:#353a5a;
  --gold:#c8a84b;--gold2:#e8c870;--gold3:#f5d98a;
  --red:#d9453a;--grn:#42c87a;--blu:#4a9fd4;--pur:#b06ae0;
  --dim:#424870;--text:#b8bdd8;--textd:#606888;
  --mono:'Courier New',monospace;--sans:'Arial Narrow',Arial,sans-serif;
  --p0:#e8543a;--p1:#4a9fd4;--p2:#42c87a;--p3:#b06ae0;
  --p4:#e8c870;--p5:#d44a88;--p6:#42c8c8;--p7:#ff8c42;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html,body{width:100%;height:100%;background:var(--bg);color:var(--text);font-family:var(--sans);overflow:hidden;user-select:none}
#app{width:100vw;height:100vh;position:relative}

/* ── Screens ── */
.screen{position:absolute;inset:0;display:none;align-items:center;justify-content:center;flex-direction:column}
.screen.active{display:flex}

/* ── Menu Background Animated Canvas ── */
#bg-canvas{position:absolute;inset:0;width:100%;height:100%;opacity:.3;pointer-events:none}

/* ── Menu ── */
.menu-wrap{position:relative;display:flex;flex-direction:column;align-items:center;gap:44px}
.title-eyebrow{font-family:var(--mono);font-size:11px;letter-spacing:.35em;color:var(--gold);text-transform:uppercase;margin-bottom:4px}
.title-main{font-family:var(--sans);font-size:clamp(60px,9vw,112px);font-weight:900;letter-spacing:-.02em;line-height:.9;color:#fff;text-shadow:0 0 30px rgba(200,168,75,.5),0 0 80px rgba(200,168,75,.15),0 2px 0 rgba(0,0,0,.8)}
.title-sub{font-family:var(--mono);font-size:10px;letter-spacing:.25em;color:var(--dim);margin-top:14px}
.menu-btns{display:flex;flex-direction:column;gap:10px;align-items:stretch;width:270px}
.menu-footer{font-family:var(--mono);font-size:9px;color:var(--textd);letter-spacing:.15em;margin-top:-20px}

/* ── Buttons ── */
.btn{font-family:var(--sans);font-weight:700;font-size:14px;letter-spacing:.12em;text-transform:uppercase;padding:11px 26px;border:2px solid transparent;cursor:pointer;background:transparent;transition:all .12s;clip-path:polygon(8px 0%,100% 0%,calc(100% - 8px) 100%,0% 100%)}
.btn-gold{border-color:var(--gold);color:var(--gold)}
.btn-gold:hover{background:var(--gold);color:#000;box-shadow:0 0 18px rgba(200,168,75,.45)}
.btn-dim{border-color:var(--border2);color:var(--textd)}
.btn-dim:hover{border-color:var(--text);color:var(--text)}
.btn-grn{border-color:var(--grn);color:var(--grn)}
.btn-grn:hover,.btn-grn.on{background:var(--grn);color:#000}
.btn-red{border-color:var(--red);color:var(--red)}
.btn-red:hover{background:var(--red);color:#fff}
.btn-sm{font-size:11px;padding:6px 14px;clip-path:polygon(5px 0%,100% 0%,calc(100% - 5px) 100%,0% 100%)}
.btn-row{display:flex;gap:10px;justify-content:flex-end;margin-top:22px}

/* ── Panel ── */
.panel{background:var(--panel);border:1px solid var(--border);padding:32px 36px;width:90vw;max-width:640px;max-height:88vh;overflow-y:auto}
.panel-lg{max-width:720px}
.panel-sm{max-width:480px}
.panel-title{font-family:var(--sans);font-size:26px;font-weight:900;letter-spacing:.08em;color:var(--gold);border-bottom:1px solid var(--border);padding-bottom:14px;margin-bottom:22px;text-transform:uppercase}
.section-label{font-family:var(--mono);font-size:10px;letter-spacing:.2em;color:var(--gold);margin-bottom:9px;text-transform:uppercase}

/* ── Inputs ── */
.inp{font-family:var(--mono);font-size:13px;padding:9px 11px;border:1px solid var(--border2);background:var(--bg2);color:var(--text);outline:none;width:100%;transition:border-color .12s;letter-spacing:.05em}
.inp:focus{border-color:var(--gold)}
.inp::placeholder{color:var(--textd)}
.inp-code{letter-spacing:.3em;font-size:18px;text-align:center;text-transform:uppercase}
.inp-group{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}

/* ── Counter ── */
.ctr{display:flex;align-items:center;gap:12px}
.ctr-btn{width:26px;height:26px;border:1px solid var(--border2);background:none;color:var(--gold);font-size:16px;cursor:pointer;font-family:var(--mono)}
.ctr-btn:hover{border-color:var(--gold);background:rgba(200,168,75,.1)}
.ctr-val{font-family:var(--sans);font-weight:900;font-size:26px;color:var(--gold);min-width:36px;text-align:center}

/* ── Online Menu ── */
.online-split{display:grid;grid-template-columns:1fr auto 1fr;gap:0;align-items:start}
.online-col{padding:0 20px;display:flex;flex-direction:column;gap:10px}
.online-col:first-child{padding-left:0}
.online-col:last-child{padding-right:0}
.online-div{width:1px;background:var(--border);margin:24px 0 0;align-self:stretch}
.or-label{font-family:var(--mono);font-size:10px;color:var(--dim);letter-spacing:.2em;padding:8px 12px;writing-mode:vertical-rl}

/* ── Lobby ── */
.lobby-code-row{display:flex;align-items:center;gap:14px;padding-bottom:18px;margin-bottom:18px;border-bottom:1px solid var(--border)}
.lobby-code-val{font-family:var(--mono);font-size:30px;font-weight:700;color:var(--gold2);letter-spacing:.35em}
.lobby-code-lbl{font-family:var(--mono);font-size:10px;color:var(--textd);letter-spacing:.15em}
.lobby-pl-header{display:flex;justify-content:space-between;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd);margin-bottom:7px}
.lobby-pl-list{min-height:90px;max-height:180px;overflow-y:auto;border:1px solid var(--border);padding:6px}
.pl-row{display:flex;align-items:center;gap:9px;padding:5px 7px;border-bottom:1px solid var(--border);font-family:var(--mono);font-size:11px}
.pl-row:last-child{border:none}
.pl-dot{width:9px;height:9px;flex-shrink:0;clip-path:polygon(2px 0%,100% 0%,calc(100% - 2px) 100%,0% 100%)}
.pl-name{flex:1;color:var(--text)}
.pl-ping{color:var(--textd);font-size:10px}
.pl-ready{font-size:10px}
.pl-ready.y{color:var(--grn)}
.pl-ready.n{color:var(--red)}
.pl-host{color:var(--gold);font-size:10px}
.lobby-settings-row{display:flex;align-items:center;gap:14px;margin-bottom:14px;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd)}
.status{font-family:var(--mono);font-size:10px;min-height:18px;margin-top:10px;letter-spacing:.1em}
.status.err{color:var(--red)}.status.ok{color:var(--grn)}.status.info{color:var(--gold)}

/* ── Key Bindings ── */
.bindings-wrap{display:flex;flex-direction:column;gap:10px;margin-bottom:20px}
.binding-group{border:1px solid var(--border);padding:12px 14px}
.binding-title{font-family:var(--mono);font-size:10px;letter-spacing:.2em;color:var(--gold);margin-bottom:9px}
.binding-grid{display:grid;grid-template-columns:60px 1fr;gap:6px;align-items:center}
.binding-lbl{font-family:var(--mono);font-size:10px;color:var(--textd)}
.key-btn{font-family:var(--mono);font-size:11px;padding:4px 9px;min-width:66px;border:1px solid var(--border2);background:var(--bg2);color:var(--text);cursor:pointer;text-align:center;transition:all .1s}
.key-btn.listening{border-color:var(--gold);color:var(--gold);animation:kpulse .7s infinite}
@keyframes kpulse{0%,100%{opacity:1}50%{opacity:.4}}
.player-count-row{display:flex;align-items:center;gap:18px;margin-bottom:20px;font-family:var(--mono);font-size:10px;letter-spacing:.15em;color:var(--textd)}

/* ── HUD ── */
#screen-game{background:#000;justify-content:flex-start}
.hud{width:100%;height:38px;background:rgba(9,9,15,.96);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 14px;font-family:var(--mono);font-size:10px;letter-spacing:.1em;color:var(--textd);flex-shrink:0;gap:16px}
.hud-l{flex:1}.hud-c{flex:2;display:flex;justify-content:center;gap:18px;flex-wrap:wrap}.hud-r{flex:1;display:flex;justify-content:flex-end;gap:14px}
.hud-score{display:flex;align-items:center;gap:5px;font-size:11px}
.hud-dot{width:7px;height:7px;clip-path:polygon(2px 0,100% 0,calc(100% - 2px) 100%,0 100%)}
.hud-round{color:var(--gold);font-weight:700}
#game-canvas{display:block;width:100%;height:calc(100vh - 38px);background:#000}
.game-overlay{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(9,9,15,.93);border:2px solid var(--gold);padding:28px 60px;text-align:center;pointer-events:none}
.game-overlay.hidden{display:none}
.ov-title{font-family:var(--sans);font-size:44px;font-weight:900;color:var(--gold);letter-spacing:.06em}
.ov-sub{font-family:var(--mono);font-size:13px;color:var(--text);margin-top:6px;letter-spacing:.14em}

/* ── Scoreboard ── */
.score-list{margin-bottom:22px}
.score-row{display:flex;align-items:center;gap:14px;padding:11px 14px;border-bottom:1px solid var(--border)}
.score-row:last-child{border:none}
.score-rank{font-size:26px;font-weight:900;color:var(--textd);width:36px}
.score-rank.r1{color:var(--gold2)}
.score-bar{width:5px;height:34px;flex-shrink:0}
.score-name{flex:1;font-size:18px;font-weight:700;letter-spacing:.05em}
.score-kills{font-family:var(--mono);font-size:12px;color:var(--textd)}
.score-wins{font-family:var(--sans);font-weight:900;font-size:32px;color:var(--gold);min-width:50px;text-align:right}

/* ── How to Play ── */
.howto-grid{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:24px}
.howto-sec h4{font-family:var(--mono);font-size:10px;color:var(--gold);letter-spacing:.2em;margin-bottom:8px}
.howto-sec p{font-size:13px;color:var(--text);line-height:1.6}
.ctrl-list{font-family:var(--mono);font-size:11px}
.ctrl-row-h{display:flex;align-items:center;gap:8px;margin-bottom:5px}
.pchip{padding:2px 6px;font-size:10px;font-weight:700;clip-path:polygon(3px 0,100% 0,calc(100% - 3px) 100%,0 100%)}

/* ── Scrollbar ── */
::-webkit-scrollbar{width:3px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border2)}
.hidden{display:none!important}
</style>
</head>
<body>
<div id="app">

<!-- ═══ SCREEN: MENU ═══ -->
<div id="screen-menu" class="screen active">
  <canvas id="bg-canvas"></canvas>
  <div class="menu-wrap">
    <div>
      <div class="title-eyebrow">Armored Combat System</div>
      <div class="title-main">TANK SIEGE</div>
      <div class="title-sub">MULTIPLAYER ARENA &nbsp;·&nbsp; BROWSER EDITION &nbsp;·&nbsp; WebRTC P2P</div>
    </div>
    <div class="menu-btns">
      <button class="btn btn-gold" id="btn-local">LOCAL MULTIPLAYER</button>
      <button class="btn btn-gold" id="btn-online">ONLINE MULTIPLAYER</button>
      <button class="btn btn-dim" id="btn-howto">HOW TO PLAY</button>
    </div>
    <div class="menu-footer">WebRTC DataChannels &nbsp;·&nbsp; Host-Authoritative &nbsp;·&nbsp; 60 Hz Fixed-Tick Simulation</div>
  </div>
</div>

<!-- ═══ SCREEN: HOW TO PLAY ═══ -->
<div id="screen-howto" class="screen">
  <div class="panel">
    <div class="panel-title">How to Play</div>
    <div class="howto-grid">
      <div class="howto-sec">
        <h4>Objective</h4>
        <p>Be the last tank alive each round. Bullets bounce off walls up to 5 times — including onto yourself. Scores track wins across rounds.</p>
      </div>
      <div class="howto-sec">
        <h4>Bullet Physics</h4>
        <p>Reflection uses R = V − 2(V·N)N. Each bullet starts with 5 bounce credits. Exceeding the limit destroys the bullet. Tanks have no health — one hit kills.</p>
      </div>
      <div class="howto-sec">
        <h4>Online Mode</h4>
        <p>Host creates lobby &amp; shares the 6-char join code. All game logic runs on the host. Clients send inputs only; the host runs the full simulation and sends state snapshots at ~20 Hz. Client-side prediction keeps it feeling smooth.</p>
      </div>
      <div class="howto-sec">
        <h4>Maze</h4>
        <p>Each round generates a new maze using seeded DFS. All players use the same seed for identical layouts. Maze is always fully connected — no dead-end chambers.</p>
      </div>
    </div>
    <div class="section-label" style="margin-bottom:12px">Default Controls</div>
    <div class="ctrl-list">
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p0);color:#fff">P1</span> W/S move · A/D rotate · Space fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p1);color:#fff">P2</span> ↑/↓ move · ←/→ rotate · Enter fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p2);color:#000">P3</span> T/G move · F/H rotate · R fire</div>
      <div class="ctrl-row-h"><span class="pchip" style="background:var(--p3);color:#fff">P4</span> I/K move · J/L rotate · U fire</div>
    </div>
    <div class="btn-row"><button class="btn btn-dim" id="btn-howto-back">Back</button></div>
  </div>
</div>

<!-- ═══ SCREEN: LOCAL SETUP ═══ -->
<div id="screen-local" class="screen">
  <div class="panel panel-lg">
    <div class="panel-title">Local Multiplayer</div>
    <div class="player-count-row">
      <span>Players:</span>
      <div class="ctr">
        <button class="ctr-btn" id="local-dec">−</button>
        <span class="ctr-val" id="local-count">2</span>
        <button class="ctr-btn" id="local-inc">+</button>
      </div>
    </div>
    <div id="bindings-wrap" class="bindings-wrap"></div>
    <div class="btn-row">
      <button class="btn btn-dim" id="btn-local-back">Back</button>
      <button class="btn btn-gold" id="btn-local-start">Start Game</button>
    </div>
  </div>
</div>

<!-- ═══ SCREEN: ONLINE MENU ═══ -->
<div id="screen-online" class="screen">
  <div class="panel">
    <div class="panel-title">Online Multiplayer</div>
    <div class="online-split">
      <div class="online-col">
        <div class="section-label">Host a Game</div>
        <div class="inp-group">
          <input class="inp" id="host-name" placeholder="Your Name" maxlength="14">
        </div>
        <button class="btn btn-gold" id="btn-host">Create Lobby</button>
      </div>
      <div class="online-div"><span class="or-label">OR</span></div>
      <div class="online-col">
        <div class="section-label">Join a Game</div>
        <div class="inp-group">
          <input class="inp" id="join-name" placeholder="Your Name" maxlength="14">
          <input class="inp inp-code" id="join-code" placeholder="JOIN CODE" maxlength="6">
        </div>
        <button class="btn btn-gold" id="btn-join">Join Lobby</button>
      </div>
    </div>
    <div class="btn-row" style="margin-top:18px">
      <button class="btn btn-dim" id="btn-online-back">Back</button>
    </div>
    <div class="status info" id="online-status"></div>
  </div>
</div>

<!-- ═══ SCREEN: LOBBY ═══ -->
<div id="screen-lobby" class="screen">
  <div class="panel panel-sm">
    <div class="panel-title">Lobby</div>
    <div class="lobby-code-row">
      <div>
        <div class="lobby-code-lbl">Join Code</div>
        <div class="lobby-code-val" id="lobby-code-val">------</div>
      </div>
      <button class="btn btn-dim btn-sm" id="btn-copy-code">Copy</button>
    </div>
    <div id="lobby-host-settings" class="lobby-settings-row">
      <span>Max Players:</span>
      <div class="ctr">
        <button class="ctr-btn" id="lobby-max-dec">−</button>
        <span class="ctr-val" id="lobby-max-val" style="font-size:20px">8</span>
        <button class="ctr-btn" id="lobby-max-inc">+</button>
      </div>
    </div>
    <div class="lobby-pl-header"><span>Players</span><span id="lobby-pl-count">0/8</span></div>
    <div class="lobby-pl-list" id="lobby-pl-list"></div>
    <div style="font-family:var(--mono);font-size:10px;color:var(--textd);margin:8px 0 2px" id="lobby-ping-row"></div>
    <div class="btn-row">
      <button class="btn btn-dim btn-sm" id="btn-lobby-leave">Leave</button>
      <button class="btn btn-grn btn-sm" id="btn-ready">Ready</button>
      <button class="btn btn-gold btn-sm hidden" id="btn-lobby-start">Start Game</button>
    </div>
    <div class="status" id="lobby-status"></div>
  </div>
</div>

<!-- ═══ SCREEN: GAME ═══ -->
<div id="screen-game" class="screen">
  <div class="hud">
    <div class="hud-l"><span class="hud-round" id="hud-round">Round 1</span></div>
    <div class="hud-c" id="hud-scores"></div>
    <div class="hud-r">
      <span id="hud-fps">FPS: —</span>
      <span id="hud-ping">PING: —</span>
    </div>
  </div>
  <canvas id="game-canvas"></canvas>
  <div class="game-overlay hidden" id="game-overlay">
    <div class="ov-title" id="ov-title">Round Over</div>
    <div class="ov-sub" id="ov-sub"></div>
  </div>
</div>

<!-- ═══ SCREEN: SCOREBOARD ═══ -->
<div id="screen-scoreboard" class="screen">
  <div class="panel">
    <div class="panel-title">Scoreboard</div>
    <div class="score-list" id="score-list"></div>
    <div class="btn-row">
      <button class="btn btn-dim" id="btn-score-menu">Main Menu</button>
      <button class="btn btn-gold" id="btn-score-next">Next Round</button>
    </div>
  </div>
</div>

</div><!-- #app -->
<div id="connecting-overlay" style="display:none;position:fixed;inset:0;background:rgba(9,9,15,.92);z-index:999;align-items:center;justify-content:center;flex-direction:column;gap:16px">
  <div style="font-family:'Courier New',monospace;font-size:13px;letter-spacing:.2em;color:#c8a84b" id="connecting-msg">CONNECTING...</div>
  <div style="width:200px;height:2px;background:#252840;overflow:hidden"><div id="conn-bar" style="height:100%;background:#c8a84b;width:0;transition:width .3s"></div></div>
</div>

<script>
"use strict";
// ╔═══════════════════════════════════════════════════════════════╗
// ║  TANK SIEGE — Complete Source                                ║
// ║  Architecture:                                               ║
// ║  • Constants / Utils                                         ║
// ║  • RNG (seeded, deterministic)                               ║
// ║  • Maze generator (iterative DFS, fully connected)           ║
// ║  • Vec2 (2D vector math)                                     ║
// ║  • Physics (AABB sweep, circle-AABB, reflection)             ║
// ║  • Simulation (authoritative deterministic 60 Hz)            ║
// ║  • Packets (typed, validated)                                ║
// ║  • WebRTCHost (runs sim, broadcasts snapshots)               ║
// ║  • WebRTCClient (prediction, reconciliation, interpolation)  ║
// ║  • LocalGame (same-device multiplayer, same sim core)        ║
// ║  • Renderer (Canvas 2D, decoupled from sim)                  ║
// ║  • Particles                                                 ║
// ║  • KeyBindings                                               ║
// ║  • UI (screens, lobby, scoreboard)                           ║
// ║  • MenuBG (animated background)                              ║
// ║  • App (entry point / wiring)                                ║
// ╚═══════════════════════════════════════════════════════════════╝

// ═══════════════════════════════════════════════════════════════
// SECTION 1 — CONSTANTS
// ═══════════════════════════════════════════════════════════════
const C = Object.freeze({
  TICK_RATE: 60,
  TICK_MS: 1000 / 60,
  SNAP_RATE: 20,        // host snapshot broadcasts per second
  SNAP_INTERVAL: 3,     // send snapshot every N ticks (60/20=3)
  MAX_PLAYERS: 8,
  // World
  CELL: 52,             // px per maze cell
  COLS: 19,             // must be odd
  ROWS: 13,             // must be odd
  WALL_T: 4,            // wall render thickness (visual only, collision uses cell AABB)
  // Tank
  T_RADIUS: 13,
  T_SPEED: 110,         // px/s
  T_ROT: 2.8,           // rad/s
  T_FIRE_CD: 0.45,      // seconds
  T_BARREL: 17,         // turret length px
  // Bullet
  B_RADIUS: 4,
  B_SPEED: 300,         // px/s
  B_BOUNCES: 5,
  B_LIFE: 7,            // seconds max lifetime
  // Net
  PING_INTERVAL: 1500,
  TIMEOUT: 7000,
  // Packet type IDs
  PKT: {
    LOBBY_STATE: 1, GAME_START: 2, SNAPSHOT: 3,
    ROUND_END: 4, KICK: 5, PONG: 6,
    JOIN: 10, INPUT: 11, READY: 12, PING: 13,
  },
  // Player colors
  COLORS: ['#e8543a','#4a9fd4','#42c87a','#b06ae0','#e8c870','#d44a88','#42c8c8','#ff8c42'],
  // Default key bindings [up, down, left, right, fire]
  DEFAULT_KEYS: [
    ['KeyW','KeyS','KeyA','KeyD','Space'],
    ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter'],
    ['KeyT','KeyG','KeyF','KeyH','KeyR'],
    ['KeyI','KeyK','KeyJ','KeyL','KeyU'],
  ],
});

// ═══════════════════════════════════════════════════════════════
// SECTION 2 — UTILITIES
// ═══════════════════════════════════════════════════════════════
const Utils = {
  genCode() {
    const ch = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    return Array.from({length:6}, () => ch[Math.floor(Math.random()*ch.length)]).join('');
  },
  genId() { return Math.random().toString(36).slice(2,10).toUpperCase(); },
  clamp(v,lo,hi) { return Math.max(lo, Math.min(hi, v)); },
  lerp(a,b,t) { return a + (b-a)*t; },
  lerpAngle(a,b,t) {
    let d = b - a;
    while (d > Math.PI) d -= 2*Math.PI;
    while (d < -Math.PI) d += 2*Math.PI;
    return a + d*t;
  },
  encode(obj) { return JSON.stringify(obj); },
  decode(data) {
    try { return JSON.parse(typeof data === 'string' ? data : new TextDecoder().decode(data)); }
    catch { return null; }
  },
  now() { return performance.now(); },
  keyName(code) {
    const m = {Space:'SPC',Enter:'ENT',ArrowUp:'↑',ArrowDown:'↓',ArrowLeft:'←',ArrowRight:'→',
      ShiftLeft:'LSFT',ShiftRight:'RSFT',ControlLeft:'LCTL',ControlRight:'RCTL'};
    if (m[code]) return m[code];
    if (code.startsWith('Key')) return code.slice(3);
    if (code.startsWith('Digit')) return code.slice(5);
    if (code.startsWith('Numpad')) return 'N'+code.slice(6);
    return code.slice(0,5);
  },
  deepClone(o) { return JSON.parse(JSON.stringify(o)); },
};

// ═══════════════════════════════════════════════════════════════
// SECTION 3 — SEEDED RNG (Mulberry32)
// All randomness in simulation goes through this for determinism
// ═══════════════════════════════════════════════════════════════
class RNG {
  constructor(seed=0) { this.s = seed >>> 0; }
  next() {
    let t = (this.s += 0x6D2B79F5) >>> 0;
    t = Math.imul(t ^ t>>>15, t | 1) >>> 0;
    t ^= t + Math.imul(t ^ t>>>7, t | 61) >>> 0;
    this.s = t;
    return ((t ^ t>>>14) >>> 0) / 4294967296;
  }
  int(lo,hi) { return lo + Math.floor(this.next() * (hi-lo+1)); }
  shuffle(arr) {
    for (let i=arr.length-1; i>0; i--) {
      const j = this.int(0,i);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }
  static fromTime() { return new RNG(Date.now() & 0xFFFFFFFF); }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 4 — MAZE GENERATOR (Iterative DFS / Recursive Backtracker)
// Returns wall segments as AABBs for collision + open cells for rendering
// ═══════════════════════════════════════════════════════════════
class Maze {
  static generate(rng, cols=C.COLS, rows=C.ROWS, cell=C.CELL) {
    // grid[r][c] = 1 if passage, 0 if wall
    const grid = Array.from({length:rows}, () => new Uint8Array(cols));
    const idx = (c,r) => r*cols+c;
    const W = cols*cell, H = rows*cell;

    // Carve starting from (1,1)
    grid[1][1] = 1;
    const stack = [{c:1,r:1}];
    const dirs4 = [{dc:2,dr:0},{dc:-2,dr:0},{dc:0,dr:2},{dc:0,dr:-2}];
    while (stack.length) {
      const cur = stack[stack.length-1];
      const shuffled = rng.shuffle([...dirs4]);
      let advanced = false;
      for (const d of shuffled) {
        const nc=cur.c+d.dc, nr=cur.r+d.dr;
        if (nc>0&&nc<cols-1&&nr>0&&nr<rows-1&&!grid[nr][nc]) {
          grid[nr][nc] = 1;
          grid[cur.r+d.dr/2][cur.c+d.dc/2] = 1;
          stack.push({c:nc,r:nr});
          advanced = true;
          break;
        }
      }
      if (!advanced) stack.pop();
    }
    // Border always wall
    for(let c=0;c<cols;c++){grid[0][c]=0;grid[rows-1][c]=0;}
    for(let r=0;r<rows;r++){grid[r][0]=0;grid[r][cols-1]=0;}

    // Build AABB wall list
    const walls = [];
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        if (!grid[r][c]) walls.push({x:c*cell, y:r*cell, w:cell, h:cell});
      }
    }

    // Open cells for rendering
    const open = [];
    for (let r=0; r<rows; r++)
      for (let c=0; c<cols; c++)
        if (grid[r][c]) open.push({x:c*cell, y:r*cell, w:cell, h:cell});

    // Spawn points: collect all open passage cells (grid coords odd,odd = chamber centers)
    const spawns = [];
    for (let r=1;r<rows-1;r+=2)
      for (let c=1;c<cols-1;c+=2)
        if (grid[r][c]) spawns.push({x:c*cell+cell/2, y:r*cell+cell/2});
    rng.shuffle(spawns);

    return {cols, rows, cell, W, H, walls, open, spawns, grid};
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 5 — VEC2
// ═══════════════════════════════════════════════════════════════
class Vec2 {
  constructor(x=0,y=0){this.x=x;this.y=y;}
  add(v){return new Vec2(this.x+v.x,this.y+v.y);}
  sub(v){return new Vec2(this.x-v.x,this.y-v.y);}
  scale(s){return new Vec2(this.x*s,this.y*s);}
  dot(v){return this.x*v.x+this.y*v.y;}
  len(){return Math.hypot(this.x,this.y);}
  norm(){const l=this.len();return l?this.scale(1/l):new Vec2();}
  reflect(n){const d=this.dot(n)*2;return new Vec2(this.x-d*n.x,this.y-d*n.y);}
  rot(a){const c=Math.cos(a),s=Math.sin(a);return new Vec2(this.x*c-this.y*s,this.x*s+this.y*c);}
  static ang(a){return new Vec2(Math.cos(a),Math.sin(a));}
  distSq(v){return (this.x-v.x)**2+(this.y-v.y)**2;}
}

// ═══════════════════════════════════════════════════════════════
// SECTION 6 — PHYSICS
// All functions are pure (no mutation of game state externally)
// ═══════════════════════════════════════════════════════════════
const Physics = {
  // Resolve circle vs AABB wall list — returns {x,y,hit}
  circleWalls(x,y,r,walls) {
    let hit=false;
    for (const w of walls) {
      const cx=Utils.clamp(x, w.x, w.x+w.w);
      const cy=Utils.clamp(y, w.y, w.y+w.h);
      const dx=x-cx, dy=y-cy;
      const d2=dx*dx+dy*dy;
      if (d2 < r*r && d2 > 1e-10) {
        const d=Math.sqrt(d2), ov=r-d;
        x += (dx/d)*ov; y += (dy/d)*ov;
        hit=true;
      }
    }
    return {x,y,hit};
  },

  // Resolve all tank-tank circle overlaps (modifies array in place)
  tankTank(tanks) {
    const minD2 = (C.T_RADIUS*2)**2;
    for (let i=0;i<tanks.length;i++) {
      if(tanks[i].dead) continue;
      for (let j=i+1;j<tanks.length;j++) {
        if(tanks[j].dead) continue;
        const dx=tanks[j].x-tanks[i].x, dy=tanks[j].y-tanks[i].y;
        const d2=dx*dx+dy*dy;
        if (d2 < minD2 && d2 > 1e-10) {
          const d=Math.sqrt(d2), ov=(C.T_RADIUS*2-d)/2;
          const nx=dx/d, ny=dy/d;
          tanks[i].x -= nx*ov; tanks[i].y -= ny*ov;
          tanks[j].x += nx*ov; tanks[j].y += ny*ov;
        }
      }
    }
  },

  // Sweep moving circle vs AABB — returns {t, nx, ny} or null
  sweepCircleAABB(cx,cy,vx,vy,r,w,dt) {
    // Expand AABB by r (Minkowski sum)
    const ex=w.x-r, ey=w.y-r, ew=w.w+r*2, eh=w.h+r*2;
    let tmin=0, tmax=dt;
    let nnx=0, nny=0;
    // X slab
    if (Math.abs(vx)<1e-9) {
      if (cx<ex||cx>ex+ew) return null;
    } else {
      let t1=(ex-cx)/vx, t2=(ex+ew-cx)/vx;
      let nx1=-1,nx2=1;
      if(t1>t2){[t1,t2]=[t2,t1];[nx1,nx2]=[nx2,nx1];}
      if(t1>tmin){tmin=t1;nnx=nx1;nny=0;}
      tmax=Math.min(tmax,t2);
      if(tmin>tmax) return null;
    }
    // Y slab
    if (Math.abs(vy)<1e-9) {
      if (cy<ey||cy>ey+eh) return null;
    } else {
      let t1=(ey-cy)/vy, t2=(ey+eh-cy)/vy;
      let ny1=-1,ny2=1;
      if(t1>t2){[t1,t2]=[t2,t1];[ny1,ny2]=[ny2,ny1];}
      if(t1>tmin){tmin=t1;nnx=0;nny=ny1;}
      tmax=Math.min(tmax,t2);
      if(tmin>tmax) return null;
    }
    if(tmin<0||tmin>dt) return null;
    return {t:tmin, nx:nnx, ny:nny};
  },

  // Move bullet with wall bouncing — returns updated bullet or null if destroyed
  moveBullet(b, walls, dt) {
    let {x,y,vx,vy,bounces,maxB} = b;
    let rem = dt;
    for (let iter=0;iter<8&&rem>1e-6;iter++) {
      let tmin=rem, tnx=0, tny=0, hitWall=false;
      for (const w of walls) {
        const res = Physics.sweepCircleAABB(x,y,vx,vy,C.B_RADIUS,w,rem);
        if(res && res.t < tmin) { tmin=res.t; tnx=res.nx; tny=res.ny; hitWall=true; }
      }
      x += vx*tmin; y += vy*tmin; rem -= tmin;
      if (hitWall) {
        bounces++;
        if (bounces > maxB) return null; // destroyed
        // Reflect: R = V - 2(V·N)N
        const n = new Vec2(tnx, tny);
        const v = new Vec2(vx, vy);
        const rf = v.reflect(n);
        vx=rf.x; vy=rf.y;
        // Epsilon push off wall
        x += vx*0.001; y += vy*0.001;
      }
    }
    return {...b, x, y, vx, vy, bounces};
  },

  // Simple circle-circle bullet/tank overlap
  bulletTank(b, t) {
    if(t.dead) return false;
    const dx=b.x-t.x, dy=b.y-t.y;
    return dx*dx+dy*dy < (C.B_RADIUS+C.T_RADIUS)**2;
  },
};

// ═══════════════════════════════════════════════════════════════
// SECTION 7 — SIMULATION
// Authoritative, deterministic. Runs on host at 60 Hz.
// Also used by clients as shadow-sim for prediction.
//
// State:
//   tick: number
//   tanks: [{id,name,color,x,y,angle,dead,kills,fireCd}]
//   bullets: [{id,ownerId,x,y,vx,vy,bounces,maxB,life}]
//   roundOver: bool
//   winnerId: string|null
// ═══════════════════════════════════════════════════════════════
class Simulation {
  constructor() {
    this.maze = null;
    this.state = null;
    this._bid = 0;
  }

  init(players, maze) {
    this.maze = maze;
    this._bid = 0;
    this.state = {
      tick: 0,
      tanks: players.map((p,i) => ({
        id: p.id, name: p.name,
        color: C.COLORS[i % C.COLORS.length],
        x: maze.spawns[i % maze.spawns.length].x,
        y: maze.spawns[i % maze.spawns.length].y,
        angle: Math.PI * 0.25,
        dead: false, kills: 0, fireCd: 0,
      })),
      bullets: [],
      roundOver: false,
      winnerId: null,
    };
  }

  // Apply one batch of inputs (Map<id, inputState>) and advance tick
  tick(inputs) {
    if (!this.state || this.state.roundOver) return;
    const s = this.state;
    const dt = 1 / C.TICK_RATE;

    // 1. Apply inputs → move / fire
    for (const t of s.tanks) {
      if (t.dead) continue;
      const inp = inputs ? (inputs.get ? inputs.get(t.id) : inputs[t.id]) : null;
      if (inp) {
        if (inp.left)  t.angle -= C.T_ROT * dt;
        if (inp.right) t.angle += C.T_ROT * dt;
        if (inp.up || inp.down) {
          const spd = inp.up ? C.T_SPEED : -C.T_SPEED;
          t.x += Math.cos(t.angle) * spd * dt;
          t.y += Math.sin(t.angle) * spd * dt;
        }
        // Fire
        if (inp.fire && t.fireCd <= 0) {
          this._fireBullet(t);
          t.fireCd = C.T_FIRE_CD;
        }
      }
      t.fireCd = Math.max(0, t.fireCd - dt);
    }

    // 2. Resolve tank-wall collisions
    for (const t of s.tanks) {
      if (t.dead) continue;
      const r = Physics.circleWalls(t.x, t.y, C.T_RADIUS, this.maze.walls);
      t.x = r.x; t.y = r.y;
    }

    // 3. Resolve tank-tank
    Physics.tankTank(s.tanks);
    // Re-resolve walls after push
    for (const t of s.tanks) {
      if (t.dead) continue;
      const r = Physics.circleWalls(t.x, t.y, C.T_RADIUS, this.maze.walls);
      t.x = r.x; t.y = r.y;
    }

    // 4. Move bullets
    const killSet = new Set();
    const newBullets = [];
    for (const b of s.bullets) {
      b.life -= dt;
      if (b.life <= 0) continue;
      const nb = Physics.moveBullet(b, this.maze.walls, dt);
      if (!nb) continue; // exceeded bounce limit
      Object.assign(b, nb);

      // 5. Bullet-tank collision
      let hitSomething = false;
      for (const t of s.tanks) {
        if (Physics.bulletTank(b, t)) {
          t.dead = true;
          hitSomething = true;
          if (b.ownerId !== t.id) {
            const shooter = s.tanks.find(tt=>tt.id===b.ownerId);
            if (shooter && !shooter.dead) shooter.kills++;
          }
          killSet.add(b.id);
          break;
        }
      }
      if (!hitSomething) newBullets.push(b);
    }
    s.bullets = newBullets;

    // 6. Check round end
    const alive = s.tanks.filter(t=>!t.dead);
    if (alive.length <= 1 && s.tanks.length > 1) {
      s.roundOver = true;
      s.winnerId = alive.length === 1 ? alive[0].id : null;
    }
    // Edge case: only 1 player (solo practice) — never ends
    if (s.tanks.length === 1) {
      s.roundOver = false;
    }

    s.tick++;
  }

  _fireBullet(tank) {
    const tx = tank.x + Math.cos(tank.angle)*C.T_BARREL;
    const ty = tank.y + Math.sin(tank.angle)*C.T_BARREL;
    this.state.bullets.push({
      id: `b${++this._bid}`,
      ownerId: tank.id,
      x: tx, y: ty,
      vx: Math.cos(tank.angle)*C.B_SPEED,
      vy: Math.sin(tank.angle)*C.B_SPEED,
      bounces: 0, maxB: C.B_BOUNCES,
      life: C.B_LIFE,
    });
  }

  serialize() {
    const s = this.state;
    return {
      tick: s.tick,
      tanks: s.tanks.map(t=>({
        id:t.id,x:t.x,y:t.y,angle:t.angle,
        dead:t.dead,kills:t.kills,fireCd:t.fireCd,
      })),
      bullets: s.bullets.map(b=>({
        id:b.id,ownerId:b.ownerId,
        x:b.x,y:b.y,vx:b.vx,vy:b.vy,
        bounces:b.bounces,maxB:b.maxB,life:b.life,
      })),
      roundOver: s.roundOver,
      winnerId: s.winnerId,
    };
  }

  applySnapshot(snap) {
    if (!this.state) return;
    const s = this.state;
    s.tick = snap.tick;
    s.roundOver = snap.roundOver;
    s.winnerId = snap.winnerId;
    for (const st of snap.tanks) {
      const t = s.tanks.find(tt=>tt.id===st.id);
      if (t) Object.assign(t,{x:st.x,y:st.y,angle:st.angle,dead:st.dead,kills:st.kills,fireCd:st.fireCd});
    }
    s.bullets = snap.bullets.map(b=>({...b}));
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 8 — PACKETS
// ═══════════════════════════════════════════════════════════════
const Pkt = {
  make: (type, data={}) => ({type, ...data}),
  validate(p) {
    if (!p || typeof p !== 'object') return false;
    if (typeof p.type !== 'number') return false;
    return Object.values(C.PKT).includes(p.type);
  },
  validateInput(p) {
    return Pkt.validate(p) && p.type===C.PKT.INPUT
      && typeof p.playerId==='string'
      && typeof p.tick==='number'
      && p.inp && typeof p.inp==='object';
  },
};

// ═══════════════════════════════════════════════════════════════
// SECTION 9 — WEBRTC HOST
// ═══════════════════════════════════════════════════════════════
class WebRTCHost {
  constructor(onEvent) {
    this._onEvent = onEvent; // callback(type, data)
    this._peer = null;
    this._clients = new Map(); // playerId → {conn, name, ready, ping, lastSeen}
    this._lobbyCode = '';
    this._maxPlayers = 8;
    this._sim = null;
    this._maze = null;
    this._gameRunning = false;
    this._tickLoop = null;
    this._tick = 0;
    this._scores = new Map(); // playerId → wins
    this._round = 1;
    this._pingTimer = null;
    this._snapAccum = 0;
    // Host's own player info
    this._hostId = Utils.genId();
    this._hostName = 'Host';
    this._hostInput = {up:false,down:false,left:false,right:false,fire:false};
  }

  get hostId() { return this._hostId; }

  async createLobby(hostName) {
    this._hostName = hostName || 'Host';
    this._lobbyCode = Utils.genCode();
    this._scores.set(this._hostId, 0);

    return new Promise((resolve, reject) => {
      // PeerJS peer ID = "TS_" + lobbyCode  so clients can find us
      const peerId = 'TS_' + this._lobbyCode;
      this._peer = new Peer(peerId, {
        host: '0.peerjs.com', port: 443, secure: true, path: '/',
        config: {
          iceServers: [
            {urls:'stun:stun.l.google.com:19302'},
            {urls:'stun:stun1.l.google.com:19302'},
          ]
        },
        debug: 0,
      });

      this._peer.on('open', id => {
        this._onEvent('lobby_created', {code: this._lobbyCode, hostId: this._hostId});
        resolve(this._lobbyCode);
      });

      this._peer.on('connection', conn => {
        this._handleConnection(conn);
      });

      this._peer.on('error', err => {
        // If peer ID taken, try with random suffix
        if (err.type === 'unavailable-id') {
          this._lobbyCode = Utils.genCode();
          const newPeer = new Peer('TS_'+this._lobbyCode, {
            host:'0.peerjs.com',port:443,secure:true,path:'/',
            config:{iceServers:[{urls:'stun:stun.l.google.com:19302'}]},
            debug:0,
          });
          newPeer.on('open', () => {
            this._peer.destroy();
            this._peer = newPeer;
            this._peer.on('connection', conn => this._handleConnection(conn));
            this._onEvent('lobby_created', {code: this._lobbyCode, hostId: this._hostId});
            resolve(this._lobbyCode);
          });
          newPeer.on('error', e2 => reject(e2));
          newPeer.on('connection', conn => this._handleConnection(conn));
        } else {
          reject(err);
        }
      });

      this._peer.on('disconnected', () => {
        this._peer.reconnect();
      });
    });
  }

  _handleConnection(conn) {
    conn.on('open', () => {
      conn.on('data', raw => this._onData(conn, raw));
      conn.on('close', () => this._onDisconnect(conn));
      conn.on('error', () => this._onDisconnect(conn));
    });
  }

  _onData(conn, raw) {
    const pkt = Utils.decode(raw);
    if (!pkt || !Pkt.validate(pkt)) return;

    const P = C.PKT;
    switch (pkt.type) {
      case P.JOIN: this._handleJoin(conn, pkt); break;
      case P.READY: this._handleReady(conn, pkt); break;
      case P.INPUT: this._handleInput(conn, pkt); break;
      case P.PING: this._handlePing(conn, pkt); break;
    }
  }

  _handleJoin(conn, pkt) {
    if (!pkt.playerId || !pkt.name) return;
    if (this._clients.size >= this._maxPlayers - 1) {
      conn.send(Utils.encode(Pkt.make(C.PKT.KICK, {reason:'Lobby full'})));
      return;
    }
    if (this._gameRunning) {
      conn.send(Utils.encode(Pkt.make(C.PKT.KICK, {reason:'Game in progress'})));
      return;
    }

    const id = pkt.playerId.slice(0,12);
    this._clients.set(id, {
      conn, name: pkt.name.slice(0,14), ready: false,
      ping: -1, lastSeen: Utils.now(),
      input: {up:false,down:false,left:false,right:false,fire:false},
    });
    if (!this._scores.has(id)) this._scores.set(id, 0);

    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  _handleReady(conn, pkt) {
    const cl = this._findClient(conn);
    if (!cl) return;
    cl.ready = pkt.isReady;
    cl.lastSeen = Utils.now();
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  _handleInput(conn, pkt) {
    if (!Pkt.validateInput(pkt)) return;
    const cl = this._findClient(conn);
    if (!cl) return;
    cl.lastSeen = Utils.now();
    cl.input = pkt.inp;
  }

  _handlePing(conn, pkt) {
    const cl = this._findClient(conn);
    if (cl) {
      cl.lastSeen = Utils.now();
      const now = Utils.now();
      cl.ping = now - (pkt.clientTime||now);
    }
    conn.send(Utils.encode(Pkt.make(C.PKT.PONG, {clientTime: pkt.clientTime, serverTime: Utils.now()})));
  }

  _onDisconnect(conn) {
    const entry = [...this._clients.entries()].find(([,v])=>v.conn===conn);
    if (!entry) return;
    this._clients.delete(entry[0]);
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
    this._onEvent('player_left', {id: entry[0]});
  }

  _findClient(conn) {
    return [...this._clients.values()].find(c=>c.conn===conn) || null;
  }

  _getLobbyData() {
    const players = [
      {id:this._hostId, name:this._hostName, ready:true, ping:-1, isHost:true, color:C.COLORS[0]},
      ...[...this._clients.entries()].map(([id,cl],i)=>({
        id, name:cl.name, ready:cl.ready, ping:cl.ping, isHost:false,
        color:C.COLORS[(i+1)%C.COLORS.length],
      })),
    ];
    return {players, maxPlayers:this._maxPlayers, code:this._lobbyCode};
  }

  _broadcastLobbyState() {
    const data = this._getLobbyData();
    const pkt = Utils.encode(Pkt.make(C.PKT.LOBBY_STATE, data));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }
  }

  setMaxPlayers(n) {
    this._maxPlayers = Utils.clamp(n, 2, C.MAX_PLAYERS);
    this._broadcastLobbyState();
    this._onEvent('lobby_changed', this._getLobbyData());
  }

  setHostInput(inp) { this._hostInput = inp; }

  startGame(seed) {
    if (this._gameRunning) return;
    seed = seed || (Date.now() & 0xFFFFFFFF);
    this._gameRunning = true;
    this._round++;

    const players = this._getLobbyData().players;
    const rng = new RNG(seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(players, this._maze);

    // Init scores for new players
    for (const p of players) {
      if (!this._scores.has(p.id)) this._scores.set(p.id, 0);
    }

    // Broadcast start
    const startPkt = Utils.encode(Pkt.make(C.PKT.GAME_START, {round: this._round,
      seed, players, tick: 0,
    }));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(startPkt); } catch {}
    }

    this._onEvent('game_start', {sim: this._sim, maze: this._maze, players, scores: this._getScores(), round: this._round});

    // Timeout checker
    this._pingTimer = setInterval(() => this._checkTimeouts(), 1000);

    // 60 Hz simulation loop
    let lastTime = Utils.now();
    let accumMs = 0;
    let snapTick = 0;

    const loop = () => {
      if (!this._gameRunning) return;
      this._tickLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accumMs += now - lastTime;
      lastTime = now;

      while (accumMs >= C.TICK_MS) {
        accumMs -= C.TICK_MS;
        this._doTick();

        // Send snapshot every SNAP_INTERVAL ticks
        snapTick++;
        if (snapTick >= C.SNAP_INTERVAL) {
          snapTick = 0;
          this._sendSnapshot();
        }

        // Check round end
        if (this._sim.state.roundOver) {
          this._handleRoundEnd();
          return;
        }
      }
    };
    this._tickLoop = requestAnimationFrame(loop);
  }

  _doTick() {
    // Collect all inputs
    const inputs = new Map();
    inputs.set(this._hostId, this._hostInput);
    for (const [id, cl] of this._clients.entries()) {
      inputs.set(id, cl.input || {up:false,down:false,left:false,right:false,fire:false});
    }
    this._sim.tick(inputs);
  }

  _sendSnapshot() {
    const snap = this._sim.serialize();
    const pkt = Utils.encode(Pkt.make(C.PKT.SNAPSHOT, {snap, serverTime: Utils.now()}));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }
  }

  _handleRoundEnd() {
    cancelAnimationFrame(this._tickLoop);
    this._tickLoop = null;
    this._gameRunning = false;

    const wid = this._sim.state.winnerId;
    if (wid) {
      this._scores.set(wid, (this._scores.get(wid)||0) + 1);
    }

    const scores = this._getScores();
    const pkt = Utils.encode(Pkt.make(C.PKT.ROUND_END, {winnerId: wid, scores}));
    for (const cl of this._clients.values()) {
      try { cl.conn.send(pkt); } catch {}
    }

    this._onEvent('round_end', {winnerId: wid, scores});
  }

  _getScores() {
    const arr = [];
    const lobby = this._getLobbyData();
    for (const p of lobby.players) {
      arr.push({id:p.id, name:p.name, color:p.color, wins:this._scores.get(p.id)||0,
        kills: this._sim?.state.tanks.find(t=>t.id===p.id)?.kills || 0});
    }
    return arr;
  }

  _checkTimeouts() {
    const now = Utils.now();
    for (const [id, cl] of this._clients.entries()) {
      if (now - cl.lastSeen > C.TIMEOUT) {
        try { cl.conn.close(); } catch {}
        this._clients.delete(id);
        this._broadcastLobbyState();
        this._onEvent('lobby_changed', this._getLobbyData());
        this._onEvent('player_left', {id});
      }
    }
  }

  destroy() {
    cancelAnimationFrame(this._tickLoop);
    clearInterval(this._pingTimer);
    this._gameRunning = false;
    for (const cl of this._clients.values()) { try { cl.conn.close(); } catch {} }
    try { this._peer.destroy(); } catch {}
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 10 — WEBRTC CLIENT
// Connects to host, sends inputs, receives snapshots
// Runs shadow simulation for client-side prediction
// ═══════════════════════════════════════════════════════════════
class WebRTCClient {
  constructor(onEvent) {
    this._onEvent = onEvent;
    this._peer = null;
    this._conn = null;
    this._playerId = Utils.genId();
    this._playerName = '';
    this._sim = null;      // shadow simulation
    this._maze = null;
    this._ping = -1;
    this._pingTimer = null;
    this._timeoutTimer = null;
    this._lastServerTime = 0;
    this._lastLocalTime = 0;
    this._input = {up:false,down:false,left:false,right:false,fire:false};
    this._lastInputSent = {...this._input};
    this._connected = false;
    this._lobbyPlayers = [];
    this._ready = false;
    this._renderLoop = null;
    this._gameStarted = false;
  }

  get playerId() { return this._playerId; }
  get ping() { return this._ping; }

  async join(name, code) {
    this._playerName = name || 'Player';
    const hostPeerId = 'TS_' + code.toUpperCase();

    return new Promise((resolve, reject) => {
      this._peer = new Peer({
        host: '0.peerjs.com', port: 443, secure: true, path: '/',
        config: {
          iceServers: [
            {urls:'stun:stun.l.google.com:19302'},
            {urls:'stun:stun1.l.google.com:19302'},
          ]
        },
        debug: 0,
      });

      this._peer.on('open', () => {
        this._conn = this._peer.connect(hostPeerId, {reliable: true, serialization: 'none'});
        this._conn.on('open', () => {
          this._connected = true;
          // Send join request
          this._send(Pkt.make(C.PKT.JOIN, {
            playerId: this._playerId, name: this._playerName,
          }));
          // Start ping loop
          this._pingTimer = setInterval(() => this._doPing(), C.PING_INTERVAL);
          this._resetTimeout();
          resolve();
        });
        this._conn.on('data', raw => this._onData(raw));
        this._conn.on('close', () => this._onDisconnect());
        this._conn.on('error', () => this._onDisconnect());

        this._peer.on('error', err => {
          if (!this._connected) reject(err);
          else this._onDisconnect();
        });
      });

      this._peer.on('error', err => reject(err));
    });
  }

  _onData(raw) {
    const pkt = Utils.decode(raw);
    if (!pkt || !Pkt.validate(pkt)) return;
    this._resetTimeout();

    const P = C.PKT;
    switch (pkt.type) {
      case P.LOBBY_STATE:
        this._lobbyPlayers = pkt.players || [];
        this._onEvent('lobby_state', {players: pkt.players, maxPlayers: pkt.maxPlayers, code: pkt.code});
        break;
      case P.GAME_START:
        this._startGame(pkt);
        break;
      case P.SNAPSHOT:
        this._applySnapshot(pkt);
        break;
      case P.ROUND_END:
        this._onEvent('round_end', {winnerId: pkt.winnerId, scores: pkt.scores});
        break;
      case P.KICK:
        this._onEvent('kicked', {reason: pkt.reason});
        this.destroy();
        break;
      case P.PONG:
        this._handlePong(pkt);
        break;
    }
  }

  _startGame(pkt) {
    this._gameStarted = true;
    const rng = new RNG(pkt.seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(pkt.players, this._maze);
    this._onEvent('game_start', {
      sim: this._sim, maze: this._maze,
      players: pkt.players,
      myId: this._playerId,
      round: pkt.round || 1,
    });
    // Start input sending loop
    this._startInputLoop();
  }

  _applySnapshot(pkt) {
    if (!this._sim) return;
    const snap = pkt.snap;
    this._lastServerTime = pkt.serverTime;
    this._lastLocalTime = Utils.now();

    // Reconciliation: apply authoritative snapshot
    this._sim.applySnapshot(snap);

    this._onEvent('snapshot', {snap, ping: this._ping});
  }

  _startInputLoop() {
    // Send inputs at 60 Hz (same as tick rate)
    let tick = 0;
    let last = Utils.now();
    let accum = 0;
    const loop = () => {
      if (!this._gameStarted || !this._connected) return;
      this._renderLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accum += now - last;
      last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        this._sendInput(tick++);
      }
    };
    this._renderLoop = requestAnimationFrame(loop);
  }

  _sendInput(tick) {
    this._send(Pkt.make(C.PKT.INPUT, {
      playerId: this._playerId,
      tick,
      inp: this._input,
    }));
  }

  setInput(inp) { this._input = inp; }

  setReady(isReady) {
    this._ready = isReady;
    this._send(Pkt.make(C.PKT.READY, {playerId: this._playerId, isReady}));
  }

  _doPing() {
    this._send(Pkt.make(C.PKT.PING, {clientTime: Utils.now()}));
  }

  _handlePong(pkt) {
    if (pkt.clientTime) {
      this._ping = Utils.now() - pkt.clientTime;
      this._onEvent('ping', {ping: this._ping});
    }
  }

  _resetTimeout() {
    clearTimeout(this._timeoutTimer);
    this._timeoutTimer = setTimeout(() => this._onDisconnect(), C.TIMEOUT);
  }

  _onDisconnect() {
    if (!this._connected) return;
    this._connected = false;
    this._onEvent('disconnected', {});
    this.destroy();
  }

  _send(obj) {
    if (!this._conn || !this._connected) return;
    try { this._conn.send(Utils.encode(obj)); } catch {}
  }

  destroy() {
    this._gameStarted = false;
    this._connected = false;
    clearInterval(this._pingTimer);
    clearTimeout(this._timeoutTimer);
    cancelAnimationFrame(this._renderLoop);
    try { this._conn?.close(); } catch {}
    try { this._peer?.destroy(); } catch {}
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 11 — LOCAL MULTIPLAYER
// Same keyboard, no networking needed
// ═══════════════════════════════════════════════════════════════
class LocalGame {
  constructor(onEvent) {
    this._onEvent = onEvent;
    this._sim = null;
    this._maze = null;
    this._players = [];
    this._keyBindings = []; // [{up,down,left,right,fire}] per player
    this._keys = new Set();
    this._tickLoop = null;
    this._round = 1;
    this._scores = new Map();
    this._gameRunning = false;
    this._keyHandler = null;
    this._keyUpHandler = null;
  }

  init(players, keyBindings) {
    this._players = players;
    this._keyBindings = keyBindings;
    this._round = 1;
    this._scores = new Map();
    players.forEach(p => this._scores.set(p.id, 0));
    this._setupKeys();
  }

  _setupKeys() {
    if (this._keyHandler) {
      window.removeEventListener('keydown', this._keyHandler);
      window.removeEventListener('keyup', this._keyUpHandler);
    }
    this._keyHandler = e => { e.preventDefault(); this._keys.add(e.code); };
    this._keyUpHandler = e => { this._keys.delete(e.code); };
    window.addEventListener('keydown', this._keyHandler, {passive:false});
    window.addEventListener('keyup', this._keyUpHandler, {passive:false});
  }

  startRound() {
    this._gameRunning = true;
    const seed = Date.now() & 0xFFFFFFFF;
    const rng = new RNG(seed);
    this._maze = Maze.generate(rng);
    this._sim = new Simulation();
    this._sim.init(this._players, this._maze);
    this._round++;

    this._onEvent('game_start', {
      sim: this._sim, maze: this._maze,
      players: this._players,
      scores: this._getScores(),
      round: this._round,
    });

    let last = Utils.now(), accum = 0;
    const loop = () => {
      if (!this._gameRunning) return;
      this._tickLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      accum += now - last; last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        this._doTick();
        if (this._sim.state.roundOver) {
          this._handleRoundEnd();
          return;
        }
      }
    };
    this._tickLoop = requestAnimationFrame(loop);
  }

  _doTick() {
    const inputs = new Map();
    for (let i=0; i<this._players.length; i++) {
      const kb = this._keyBindings[i];
      inputs.set(this._players[i].id, {
        up:    this._keys.has(kb.up),
        down:  this._keys.has(kb.down),
        left:  this._keys.has(kb.left),
        right: this._keys.has(kb.right),
        fire:  this._keys.has(kb.fire),
      });
    }
    this._sim.tick(inputs);
  }

  _handleRoundEnd() {
    cancelAnimationFrame(this._tickLoop);
    this._gameRunning = false;
    const wid = this._sim.state.winnerId;
    if (wid) this._scores.set(wid, (this._scores.get(wid)||0)+1);
    this._onEvent('round_end', {winnerId: wid, scores: this._getScores()});
  }

  _getScores() {
    return this._players.map((p,i) => ({
      id: p.id, name: p.name,
      color: C.COLORS[i%C.COLORS.length],
      wins: this._scores.get(p.id)||0,
      kills: this._sim?.state.tanks.find(t=>t.id===p.id)?.kills||0,
    }));
  }

  getInput(playerIdx) {
    const kb = this._keyBindings[playerIdx];
    if (!kb) return null;
    return {
      up: this._keys.has(kb.up), down: this._keys.has(kb.down),
      left: this._keys.has(kb.left), right: this._keys.has(kb.right),
      fire: this._keys.has(kb.fire),
    };
  }

  stopRound() {
    cancelAnimationFrame(this._tickLoop);
    this._gameRunning = false;
  }

  destroy() {
    this.stopRound();
    if (this._keyHandler) {
      window.removeEventListener('keydown', this._keyHandler);
      window.removeEventListener('keyup', this._keyUpHandler);
    }
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 12 — PARTICLES
// ═══════════════════════════════════════════════════════════════
class Particles {
  constructor() { this._ps = []; }

  explosion(x, y, color, count=18) {
    for (let i=0; i<count; i++) {
      const a = (Math.PI*2/count)*i + (Math.random()-.5)*.5;
      const spd = 40 + Math.random()*120;
      this._ps.push({
        x, y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd,
        life: 0.4+Math.random()*0.5, maxLife: 0.9,
        r: 2+Math.random()*3, color,
      });
    }
  }

  bulletTrail(x, y, color) {
    this._ps.push({
      x: x+(Math.random()-.5)*3, y: y+(Math.random()-.5)*3,
      vx: (Math.random()-.5)*20, vy: (Math.random()-.5)*20,
      life: 0.06, maxLife: 0.06, r: 1.5, color,
    });
  }

  update(dt) {
    this._ps = this._ps.filter(p => {
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= 0.92; p.vy *= 0.92;
      p.life -= dt;
      return p.life > 0;
    });
  }

  draw(ctx, camX, camY) {
    for (const p of this._ps) {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha * 0.85;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x - camX, p.y - camY, p.r * alpha, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 13 — RENDERER
// Decoupled from simulation tick, runs at display refresh rate
// ═══════════════════════════════════════════════════════════════
class Renderer {
  constructor(canvas) {
    this._canvas = canvas;
    this._ctx = canvas.getContext('2d');
    this._particles = new Particles();
    this._prevTanks = null;   // for interpolation
    this._renderLoop = null;
    this._fpsFrames = 0;
    this._fpsLast = Utils.now();
    this._fps = 0;
    this._onFps = null;
    this._deadEffect = new Map(); // id → deathTime
    this._flashMap = new Map();   // id → {until, color}
  }

  start(getSim, getMaze, getPlayers, getMyId) {
    this._getSim = getSim;
    this._getMaze = getMaze;
    this._getPlayers = getPlayers;
    this._getMyId = getMyId;

    let last = Utils.now();
    const loop = () => {
      this._renderLoop = requestAnimationFrame(loop);
      const now = Utils.now();
      const dt = Math.min((now - last)/1000, 0.05);
      last = now;
      this._render(dt);
      this._updateFps();
    };
    this._renderLoop = requestAnimationFrame(loop);
  }

  stop() {
    cancelAnimationFrame(this._renderLoop);
    this._renderLoop = null;
  }

  addExplosion(x, y, color) {
    this._particles.explosion(x, y, color);
  }

  flashPlayer(id, color) {
    this._flashMap.set(id, {until: Utils.now()+200, color});
  }

  _render(dt) {
    const sim = this._getSim?.();
    const maze = this._getMaze?.();
    if (!sim || !sim.state || !maze) return;

    const canvas = this._canvas;
    const ctx = this._ctx;

    // Fit canvas to screen
    const W = canvas.parentElement?.clientWidth || canvas.clientWidth;
    const H = (canvas.parentElement?.clientHeight || canvas.clientHeight) - 0;
    if (canvas.width !== W || canvas.height !== H) {
      canvas.width = W; canvas.height = H;
    }

    // Camera: center maze on canvas
    const mW = maze.W, mH = maze.H;
    const scale = Math.min(W/mW, H/mH) * 0.96;
    const camX = (mW * scale - W) / 2 / scale;
    const camY = (mH * scale - H) / 2 / scale;
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.scale(scale, scale);

    // Background
    ctx.fillStyle = '#0d0d14';
    ctx.fillRect(camX, camY, W/scale, H/scale);

    // Floor (open cells)
    ctx.fillStyle = '#12141f';
    for (const cell of maze.open) {
      ctx.fillRect(cell.x - camX, cell.y - camY, cell.w, cell.h);
    }

    // Grid lines on floor (subtle)
    ctx.strokeStyle = 'rgba(35,38,64,0.4)';
    ctx.lineWidth = 0.5;
    for (const cell of maze.open) {
      ctx.strokeRect(cell.x - camX + 0.5, cell.y - camY + 0.5, cell.w - 1, cell.h - 1);
    }

    // Walls
    for (const w of maze.walls) {
      const wx = w.x - camX, wy = w.y - camY;
      ctx.fillStyle = '#1a1d2e';
      ctx.fillRect(wx, wy, w.w, w.h);
      // Wall highlight (top/left edges)
      ctx.strokeStyle = 'rgba(60,65,100,0.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(wx, wy+w.h); ctx.lineTo(wx, wy); ctx.lineTo(wx+w.w, wy);
      ctx.stroke();
      // Wall shadow (right/bottom)
      ctx.strokeStyle = 'rgba(5,5,10,0.9)';
      ctx.beginPath();
      ctx.moveTo(wx+w.w, wy); ctx.lineTo(wx+w.w, wy+w.h); ctx.lineTo(wx, wy+w.h);
      ctx.stroke();
    }

    // Bullets
    const s = sim.state;
    for (const b of s.bullets) {
      const owner = s.tanks.find(t=>t.id===b.ownerId);
      const col = owner ? owner.color : '#fff';
      // Trail
      this._particles.bulletTrail(b.x, b.y, col);
      // Glow
      ctx.save();
      ctx.shadowColor = col;
      ctx.shadowBlur = 8;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(b.x - camX, b.y - camY, C.B_RADIUS, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      // Inner dot
      ctx.fillStyle = col;
      ctx.beginPath();
      ctx.arc(b.x - camX, b.y - camY, C.B_RADIUS * 0.6, 0, Math.PI*2);
      ctx.fill();
    }

    // Tanks
    const myId = this._getMyId?.();
    for (const t of s.tanks) {
      this._drawTank(ctx, t, t.id === myId, camX, camY);

      // Death flash
      if (t.dead) {
        const de = this._deadEffect.get(t.id);
        if (!de) {
          this._deadEffect.set(t.id, Utils.now());
          this._particles.explosion(t.x, t.y, t.color, 24);
        }
      }
    }

    // Particles
    this._particles.update(dt);
    this._particles.draw(ctx, camX, camY);

    ctx.restore();
  }

  _drawTank(ctx, t, isMe, camX, camY) {
    if (t.dead) return;
    const x = t.x - camX, y = t.y - camY;
    const r = C.T_RADIUS, a = t.angle;

    ctx.save();
    ctx.translate(x, y);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.ellipse(2, 4, r*0.9, r*0.6, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.rotate(a);

    // Body glow (for local player)
    if (isMe) {
      ctx.shadowColor = t.color;
      ctx.shadowBlur = 10;
    }

    // Tank body (pentagon-ish via rect + rotated)
    const bodyW = r * 1.7, bodyH = r * 1.4;
    ctx.fillStyle = t.color;
    ctx.fillRect(-bodyW/2, -bodyH/2, bodyW, bodyH);

    // Darker shading
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(-bodyW/2, 0, bodyW, bodyH/2);

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(-bodyW/2, -bodyH/2, bodyW, bodyH*0.35);

    // Tracks (left & right)
    const trackW = r*0.35, trackH = r*1.5;
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(-bodyW/2 - trackW, -trackH/2, trackW, trackH);
    ctx.fillRect( bodyW/2,          -trackH/2, trackW, trackH);

    // Track links
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    for (let i=-trackH/2; i<trackH/2; i+=5) {
      ctx.beginPath();
      ctx.moveTo(-bodyW/2 - trackW, i);
      ctx.lineTo(-bodyW/2, i);
      ctx.moveTo(bodyW/2, i);
      ctx.lineTo(bodyW/2 + trackW, i);
      ctx.stroke();
    }

    // Turret base
    ctx.shadowBlur = 0;
    ctx.fillStyle = this._lerpColor(t.color, '#ffffff', 0.15);
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.52, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Barrel
    ctx.fillStyle = this._lerpColor(t.color, '#000000', 0.2);
    ctx.fillRect(0, -r*0.18, C.T_BARREL, r*0.36);
    // Barrel highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(0, -r*0.18, C.T_BARREL, r*0.1);

    // Name label
    ctx.rotate(-a);
    ctx.font = `bold ${r*0.7}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillText(t.name?.slice(0,8)||'', 1, -r*1.6+1);
    ctx.fillStyle = isMe ? '#fff' : t.color;
    ctx.fillText(t.name?.slice(0,8)||'', 0, -r*1.6);

    ctx.restore();
  }

  _lerpColor(hex1, hex2, t) {
    const p = s => parseInt(s,16);
    const r1=p(hex1.slice(1,3)),g1=p(hex1.slice(3,5)),b1=p(hex1.slice(5,7));
    const r2=p(hex2.slice(1,3)),g2=p(hex2.slice(3,5)),b2=p(hex2.slice(5,7));
    const ri=Math.round(r1+(r2-r1)*t);
    const gi=Math.round(g1+(g2-g1)*t);
    const bi=Math.round(b1+(b2-b1)*t);
    return `rgb(${ri},${gi},${bi})`;
  }

  _updateFps() {
    this._fpsFrames++;
    const now = Utils.now();
    if (now - this._fpsLast >= 500) {
      this._fps = Math.round(this._fpsFrames * 1000 / (now - this._fpsLast));
      this._fpsFrames = 0;
      this._fpsLast = now;
      this._onFps?.(this._fps);
    }
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 14 — ANIMATED MENU BACKGROUND
// ═══════════════════════════════════════════════════════════════
function startMenuBG() {
  const canvas = document.getElementById('bg-canvas');
  const ctx = canvas.getContext('2d');
  const tanks = [];
  const bullets_bg = [];

  function resize() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
  resize();
  window.addEventListener('resize', resize);

  for (let i=0;i<5;i++) {
    tanks.push({
      x: Math.random()*canvas.width, y: Math.random()*canvas.height,
      angle: Math.random()*Math.PI*2, color: C.COLORS[i%C.COLORS.length],
      vx:0,vy:0, fireCd:0,
    });
  }

  let last = Utils.now();
  function loop() {
    requestAnimationFrame(loop);
    const now = Utils.now();
    const dt = Math.min((now-last)/1000,0.05); last=now;
    const W=canvas.width, H=canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#09090f';
    ctx.fillRect(0,0,W,H);

    for (const t of tanks) {
      t.angle += 0.4*dt*(Math.sin(now*0.0003+t.x)*0.5+0.5)*2-0.2;
      t.x += Math.cos(t.angle)*40*dt;
      t.y += Math.sin(t.angle)*40*dt;
      if(t.x<0)t.x=W; if(t.x>W)t.x=0;
      if(t.y<0)t.y=H; if(t.y>H)t.y=0;
      t.fireCd -= dt;
      if(t.fireCd<=0) {
        t.fireCd = 1.5+Math.random()*2;
        bullets_bg.push({
          x:t.x+Math.cos(t.angle)*20, y:t.y+Math.sin(t.angle)*20,
          vx:Math.cos(t.angle)*180, vy:Math.sin(t.angle)*180,
          color:t.color, life:3,
        });
      }
      // Draw tank
      ctx.save();
      ctx.translate(t.x,t.y);
      ctx.globalAlpha=0.25;
      ctx.fillStyle=t.color;
      ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
      ctx.rotate(t.angle);
      ctx.fillRect(0,-4,20,8);
      ctx.restore();
    }

    for (let i=bullets_bg.length-1;i>=0;i--) {
      const b=bullets_bg[i];
      b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt;
      if(b.x<0||b.x>W||b.y<0||b.y>H||b.life<=0){bullets_bg.splice(i,1);continue;}
      ctx.globalAlpha=b.life/3*0.3;
      ctx.fillStyle=b.color;
      ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;
  }
  loop();
}

// ═══════════════════════════════════════════════════════════════
// SECTION 15 — KEY BINDINGS UI
// ═══════════════════════════════════════════════════════════════
class KeyBindingsUI {
  constructor(containerId) {
    this._container = document.getElementById(containerId);
    this._bindings = C.DEFAULT_KEYS.map(kb => ({
      up:kb[0],down:kb[1],left:kb[2],right:kb[3],fire:kb[4]
    }));
    this._playerCount = 2;
    this._listening = null; // {playerIdx, action, btn}
    this._keyHandler = null;
  }

  setPlayerCount(n) {
    this._playerCount = Utils.clamp(n, 2, C.MAX_PLAYERS);
    // Extend bindings if needed
    while (this._bindings.length < this._playerCount) {
      this._bindings.push({up:'',down:'',left:'',right:'',fire:''});
    }
    this._render();
  }

  getBindings() { return this._bindings.slice(0, this._playerCount); }

  _render() {
    this._container.innerHTML = '';
    if (this._keyHandler) window.removeEventListener('keydown', this._keyHandler);

    for (let i=0; i<this._playerCount; i++) {
      const b = this._bindings[i];
      const col = C.COLORS[i%C.COLORS.length];
      const div = document.createElement('div');
      div.className = 'binding-group';
      div.innerHTML = `
        <div class="binding-title" style="color:${col}">Player ${i+1}</div>
        <div class="binding-grid">
          ${['up','down','left','right','fire'].map(action => `
            <span class="binding-lbl">${action.toUpperCase()}</span>
            <button class="key-btn" data-player="${i}" data-action="${action}">${Utils.keyName(b[action]||'?')}</button>
          `).join('')}
        </div>`;
      this._container.appendChild(div);
    }

    // Event delegation
    this._container.querySelectorAll('.key-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (this._listening) {
          this._listening.btn.classList.remove('listening');
          this._listening.btn.textContent = Utils.keyName(this._bindings[this._listening.pi][this._listening.action]||'?');
        }
        const pi = +btn.dataset.player, action = btn.dataset.action;
        this._listening = {pi, action, btn};
        btn.classList.add('listening');
        btn.textContent = '...';
        this._startListening();
      });
    });
  }

  _startListening() {
    if (this._keyHandler) window.removeEventListener('keydown', this._keyHandler);
    this._keyHandler = e => {
      e.preventDefault();
      if (!this._listening) return;
      const {pi, action, btn} = this._listening;
      this._bindings[pi][action] = e.code;
      btn.classList.remove('listening');
      btn.textContent = Utils.keyName(e.code);
      this._listening = null;
      window.removeEventListener('keydown', this._keyHandler);
    };
    window.addEventListener('keydown', this._keyHandler);
  }
}

// ═══════════════════════════════════════════════════════════════
// SECTION 16 — SCREEN MANAGER
// ═══════════════════════════════════════════════════════════════
const Screens = {
  _active: 'menu',
  go(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById('screen-'+id);
    if (el) { el.classList.add('active'); this._active = id; }
  },
};

// ═══════════════════════════════════════════════════════════════
// SECTION 17 — APP (Main controller)
// Wires everything together
// ═══════════════════════════════════════════════════════════════
const App = (() => {
  // ── State ──────────────────────────────────────────────────
  let mode = null; // 'local' | 'host' | 'client'
  let host = null, client = null, localGame = null;
  let sim = null, maze = null;
  let players = [];
  let myId = null;
  let scores = [];
  let round = 1;
  let ping = -1;
  let keyBindingsUI = null;
  let renderer = null;
  let gameCanvas = null;
  let isHost = false;
  let isReady = false;
  let localPlayerCount = 2;

  // Online: single-player key input
  let onlineKeys = new Set();
  let onlineKeyHandler = null, onlineKeyUpHandler = null;
  const onlineBinding = {up:'KeyW',down:'KeyS',left:'KeyA',right:'KeyD',fire:'Space'};

  // ── DOM refs ───────────────────────────────────────────────
  const $ = id => document.getElementById(id);

  function init() {
    gameCanvas = $('game-canvas');
    renderer = new Renderer(gameCanvas);
    renderer._onFps = fps => { $('hud-fps').textContent = `FPS: ${fps}`; };

    keyBindingsUI = new KeyBindingsUI('bindings-wrap');
    keyBindingsUI.setPlayerCount(2);

    // Prevent F5/context menu during game
    window.addEventListener('keydown', e => {
      if (e.code === 'F5') e.preventDefault();
      // ESC to leave game (with confirm)
      if (e.code === 'Escape' && Screens._active === 'game') {
        if (confirm('Leave current game?')) leaveGame();
      }
    });
    window.addEventListener('contextmenu', e => {
      if (Screens._active === 'game') e.preventDefault();
    });

    bindMenuEvents();
    bindLobbyEvents();
    bindGameEvents();
    bindScoreEvents();
    startMenuBG();
  }

  // ── Menu ───────────────────────────────────────────────────
  function bindMenuEvents() {
    $('btn-local').onclick = () => Screens.go('local');
    $('btn-online').onclick = () => Screens.go('online');
    $('btn-howto').onclick = () => Screens.go('howto');
    $('btn-howto-back').onclick = () => Screens.go('menu');
    $('btn-local-back').onclick = () => Screens.go('menu');
    $('btn-online-back').onclick = () => Screens.go('menu');

    // Local player count
    $('local-dec').onclick = () => {
      localPlayerCount = Math.max(2, localPlayerCount - 1);
      $('local-count').textContent = localPlayerCount;
      keyBindingsUI.setPlayerCount(localPlayerCount);
    };
    $('local-inc').onclick = () => {
      localPlayerCount = Math.min(C.MAX_PLAYERS, localPlayerCount + 1);
      $('local-count').textContent = localPlayerCount;
      keyBindingsUI.setPlayerCount(localPlayerCount);
    };

    $('btn-local-start').onclick = startLocalGame;

    // Online
    $('btn-host').onclick = hostGame;
    $('btn-join').onclick = joinGame;
  }

  function startLocalGame() {
    mode = 'local';
    const bindings = keyBindingsUI.getBindings();
    players = bindings.map((_,i) => ({
      id: Utils.genId(), name: `Player ${i+1}`,
      color: C.COLORS[i%C.COLORS.length],
    }));
    localGame = new LocalGame(handleLocalEvent);
    localGame.init(players, bindings.map(b=>({...b})));

    // Setup online-style keys (for single online player in local) — not needed here
    setupOnlineKeys();

    localGame.startRound();
  }

  function handleLocalEvent(type, data) {
    switch(type) {
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; myId = null;
        scores = data.scores || [];
        round = data.round || 1;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer.start(
          () => sim, () => maze, () => players, () => myId
        );
        break;
      case 'round_end':
        scores = data.scores || [];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, true);
        }, 2200);
        showOverlay(data.winnerId);
        break;
    }
  }

  // ── Online Host ─────────────────────────────────────────────
  function showConnecting(msg) {
    const el = document.getElementById('connecting-overlay');
    document.getElementById('connecting-msg').textContent = msg;
    el.style.display = 'flex';
    let w = 0;
    const bar = document.getElementById('conn-bar');
    const iv = setInterval(() => { w = Math.min(w+3, 90); bar.style.width=w+'%'; }, 100);
    return () => { clearInterval(iv); bar.style.width='100%'; setTimeout(()=>el.style.display='none',400); };
  }

  async function hostGame() {
    const name = $('host-name').value.trim() || 'Host';
    const hideConnecting = showConnecting('CREATING LOBBY...');
    setOnlineStatus('Connecting to signaling server…', 'info');

    mode = 'host';
    isHost = true;
    myId = null; // will be set after lobby created

    host = new WebRTCHost(handleHostEvent);
    try {
      const code = await host.createLobby(name);
      myId = host.hostId;
      $('lobby-code-val').textContent = code;
      $('lobby-max-val').textContent = '8';
      $('lobby-host-settings').style.display = 'flex';
      $('btn-lobby-start').classList.remove('hidden');
      $('btn-ready').classList.add('hidden');
      isReady = true;
      updateLobbyUI(host._getLobbyData());
      hideConnecting();
      hideConnecting();
      Screens.go('lobby');
      setOnlineStatus('', '');
      setupOnlineKeys();
    } catch(err) {
      console.error(err);
      hideConnecting();
      setOnlineStatus('Failed to create lobby: ' + (err.message||err.type||err), 'err');
      host?.destroy(); host = null;
    }
  }

  function handleHostEvent(type, data) {
    switch(type) {
      case 'lobby_created':
        myId = data.hostId;
        break;
      case 'lobby_changed':
        updateLobbyUI(data);
        break;
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; scores = data.scores||[];
        round = data.round||1;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer.start(() => sim, () => maze, () => players, () => myId);
        break;
      case 'round_end':
        scores = data.scores||[];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, true);
        }, 2200);
        showOverlay(data.winnerId);
        break;
      case 'player_left':
        break;
    }
  }

  // ── Online Client ───────────────────────────────────────────
  async function joinGame() {
    const name = $('join-name').value.trim() || 'Player';
    const code = $('join-code').value.trim().toUpperCase();
    if (code.length !== 6) { setOnlineStatus('Enter a valid 6-char join code', 'err'); return; }

    const hideConnecting = showConnecting('JOINING LOBBY...');
    setOnlineStatus('Connecting…', 'info');
    mode = 'client';
    isHost = false;

    client = new WebRTCClient(handleClientEvent);
    try {
      await client.join(name, code);
      myId = client.playerId;
      $('lobby-code-val').textContent = code;
      $('lobby-host-settings').style.display = 'none';
      $('btn-lobby-start').classList.add('hidden');
      $('btn-ready').classList.remove('hidden');
      isReady = false;
      $('btn-ready').dataset.ready = 'false';
      $('btn-ready').textContent = 'Ready';
      hideConnecting();
      hideConnecting();
      Screens.go('lobby');
      setOnlineStatus('', '');
      setupOnlineKeys();
    } catch(err) {
      console.error(err);
      hideConnecting();
      setOnlineStatus('Failed to connect: ' + (err.message||err.type||err), 'err');
      client?.destroy(); client = null;
    }
  }

  function handleClientEvent(type, data) {
    switch(type) {
      case 'lobby_state':
        updateLobbyUI({players: data.players, maxPlayers: data.maxPlayers, code: data.code});
        break;
      case 'game_start':
        sim = data.sim; maze = data.maze;
        players = data.players; myId = data.myId;
        if (data.round) round = data.round;
        Screens.go('game');
        $('hud-round').textContent = `Round ${round}`;
        updateHudScores();
        renderer.stop();
        renderer._deadEffect = new Map();
        renderer.start(() => sim, () => maze, () => players, () => myId);
        break;
      case 'snapshot':
        ping = data.ping;
        $('hud-ping').textContent = ping >= 0 ? `PING: ${Math.round(ping)}ms` : 'PING: —';
        updateHudScores();
        break;
      case 'round_end':
        scores = data.scores||[];
        setTimeout(() => {
          renderer.stop();
          showScoreboard(data.winnerId, data.scores, false);
        }, 2200);
        showOverlay(data.winnerId);
        break;
      case 'ping':
        ping = data.ping;
        $('hud-ping').textContent = `PING: ${Math.round(ping)}ms`;
        // Update lobby ping display
        $('lobby-ping-row').textContent = `Your ping: ${Math.round(ping)}ms`;
        break;
      case 'kicked':
        alert('Kicked: ' + (data.reason||'unknown reason'));
        leaveGame();
        break;
      case 'disconnected':
        alert('Disconnected from host.');
        leaveGame();
        break;
    }
  }

  // ── Online Key Input Loop ────────────────────────────────────
  function setupOnlineKeys() {
    removeOnlineKeys();
    onlineKeys = new Set();
    onlineKeyHandler = e => { e.preventDefault(); onlineKeys.add(e.code); };
    onlineKeyUpHandler = e => { onlineKeys.delete(e.code); };
    window.addEventListener('keydown', onlineKeyHandler, {passive:false});
    window.addEventListener('keyup', onlineKeyUpHandler);

    // Input pump for online (host sends own input, client sends to host)
    let last = Utils.now(), accum = 0;
    function inputLoop() {
      if (!onlineKeyHandler) return;
      requestAnimationFrame(inputLoop);
      const now = Utils.now();
      accum += now - last; last = now;
      while (accum >= C.TICK_MS) {
        accum -= C.TICK_MS;
        const inp = {
          up: onlineKeys.has(onlineBinding.up),
          down: onlineKeys.has(onlineBinding.down),
          left: onlineKeys.has(onlineBinding.left),
          right: onlineKeys.has(onlineBinding.right),
          fire: onlineKeys.has(onlineBinding.fire),
        };
        if (host) host.setHostInput(inp);
        if (client) client.setInput(inp);
      }
    }
    requestAnimationFrame(inputLoop);
  }

  function removeOnlineKeys() {
    if (onlineKeyHandler) window.removeEventListener('keydown', onlineKeyHandler);
    if (onlineKeyUpHandler) window.removeEventListener('keyup', onlineKeyUpHandler);
    onlineKeyHandler = null; onlineKeyUpHandler = null;
  }

  // ── Lobby UI ─────────────────────────────────────────────────
  function bindLobbyEvents() {
    $('btn-copy-code').onclick = () => {
      const code = $('lobby-code-val').textContent;
      navigator.clipboard?.writeText(code).catch(()=>{});
      $('btn-copy-code').textContent = 'Copied!';
      setTimeout(() => $('btn-copy-code').textContent = 'Copy', 1500);
    };

    $('lobby-max-dec').onclick = () => {
      if (!host) return;
      host.setMaxPlayers(host._maxPlayers - 1);
      $('lobby-max-val').textContent = host._maxPlayers;
    };
    $('lobby-max-inc').onclick = () => {
      if (!host) return;
      host.setMaxPlayers(host._maxPlayers + 1);
      $('lobby-max-val').textContent = host._maxPlayers;
    };

    $('btn-ready').onclick = () => {
      if (!client) return;
      isReady = !isReady;
      $('btn-ready').dataset.ready = isReady ? 'true' : 'false';
      $('btn-ready').textContent = isReady ? '✓ Ready' : 'Ready';
      $('btn-ready').className = isReady ? 'btn btn-grn btn-sm on' : 'btn btn-grn btn-sm';
      client.setReady(isReady);
    };

    $('btn-lobby-start').onclick = () => {
      if (!host) return;
      host.startGame();
    };

    $('btn-lobby-leave').onclick = leaveGame;
  }

  function updateLobbyUI(data) {
    if (!data) return;
    const {players: pls, maxPlayers: mp, code} = data;
    if (code) $('lobby-code-val').textContent = code;
    $('lobby-pl-count').textContent = `${pls.length}/${mp||8}`;

    const list = $('lobby-pl-list');
    list.innerHTML = '';
    pls.forEach((p,i) => {
      const row = document.createElement('div');
      row.className = 'pl-row';
      const ping = p.ping >= 0 ? `${Math.round(p.ping)}ms` : (p.isHost ? 'host' : '—');
      row.innerHTML = `
        <div class="pl-dot" style="background:${p.color||C.COLORS[i%C.COLORS.length]}"></div>
        <span class="pl-name">${escHtml(p.name)}</span>
        <span class="pl-ping">${ping}</span>
        ${p.isHost ? '<span class="pl-host">HOST</span>' : `<span class="pl-ready ${p.ready?'y':'n'}">${p.ready?'READY':'NOT READY'}</span>`}
      `;
      list.appendChild(row);
    });
    $('lobby-max-val').textContent = mp || 8;
  }

  // ── Game ──────────────────────────────────────────────────────
  function updateHudScores() {
    const hud = $('hud-scores');
    if (!players.length) return;
    hud.innerHTML = '';
    players.forEach(p => {
      const sc = scores.find(s=>s.id===p.id);
      const wins = sc?.wins ?? 0;
      const div = document.createElement('div');
      div.className = 'hud-score';
      div.innerHTML = `<div class="hud-dot" style="background:${p.color}"></div>
        <span style="color:${p.color}">${escHtml(p.name.slice(0,8))}</span>
        <span style="color:#e8c870;font-weight:bold">${wins}</span>`;
      hud.appendChild(div);
    });
  }

  function showOverlay(winnerId) {
    const ov = $('game-overlay');
    ov.classList.remove('hidden');
    const winner = players.find(p=>p.id===winnerId);
    $('ov-title').textContent = winner ? `${winner.name} Wins!` : 'Draw!';
    $('ov-title').style.color = winner ? winner.color : 'var(--gold)';
    $('ov-sub').textContent = 'Showing scoreboard…';

    if (sim) {
      const tank = sim.state.tanks.find(t=>t.id===winnerId);
      if (tank) renderer.addExplosion(tank.x, tank.y, tank.color);
    }
  }

  function hideOverlay() { $('game-overlay').classList.add('hidden'); }

  function bindGameEvents() {
    // Game overlay auto-dismisses via setTimeout in event handlers
  }

  // ── Scoreboard ────────────────────────────────────────────────
  function showScoreboard(winnerId, scoreData, canStartNext) {
    Screens.go('scoreboard');
    hideOverlay();
    const list = $('score-list');
    list.innerHTML = '';
    const sorted = [...(scoreData||[])].sort((a,b)=>b.wins-a.wins);
    sorted.forEach((s,i) => {
      const row = document.createElement('div');
      row.className = 'score-row';
      row.innerHTML = `
        <div class="score-rank ${i===0?'r1':''}">${i===1?'2':i===2?'3':i===0?'1':i+1}</div>
        <div class="score-bar" style="background:${s.color}"></div>
        <div class="score-name" style="color:${s.color}">${escHtml(s.name)}</div>
        <div class="score-kills">${s.kills} kill${s.kills===1?'':'s'}</div>
        <div class="score-wins">${s.wins}<div style="font-family:var(--mono);font-size:9px;color:var(--textd);letter-spacing:.15em">WIN${s.wins===1?'':'S'}</div></div>
      `;
      list.appendChild(row);
    });

    $('btn-score-next').style.display = canStartNext ? '' : 'none';
    $('btn-score-next').textContent = mode==='client' ? 'Wait for host…' : 'Next Round';
    $('btn-score-next').disabled = mode==='client';
  }

  function bindScoreEvents() {
    $('btn-score-menu').onclick = () => {
      leaveGame();
      Screens.go('menu');
    };
    $('btn-score-next').onclick = () => {
      if (mode === 'local') {
        localGame.startRound();
      } else if (mode === 'host' && host) {
        host.startGame();
      }
    };
  }

  // ── Leave ──────────────────────────────────────────────────────
  function leaveGame() {
    renderer.stop();
    removeOnlineKeys();
    if (localGame) { localGame.destroy(); localGame = null; }
    if (host) { host.destroy(); host = null; }
    if (client) { client.destroy(); client = null; }
    sim = null; maze = null; players = []; myId = null;
    scores = []; isReady = false; mode = null; isHost = false;
    $('game-overlay').classList.add('hidden');
    Screens.go('menu');
  }

  // ── Helpers ────────────────────────────────────────────────────
  function setOnlineStatus(msg, cls) {
    const el = $('online-status');
    el.textContent = msg;
    el.className = 'status ' + (cls||'');
  }

  function setLobbyStatus(msg, cls) {
    const el = $('lobby-status');
    el.textContent = msg;
    el.className = 'status ' + (cls||'');
  }

  function escHtml(s) {
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  return { init };
})();

// ═══════════════════════════════════════════════════════════════
// BOOT
// ═══════════════════════════════════════════════════════════════
document.addEventListener('DOMContentLoaded', () => App.init());
</script>
</body>
</html>
